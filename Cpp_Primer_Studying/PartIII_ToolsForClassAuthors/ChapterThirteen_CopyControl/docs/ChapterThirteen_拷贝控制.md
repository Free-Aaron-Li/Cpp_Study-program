# 第十三章 拷贝控制

## 前言

类是如何控制类型对象的拷贝、赋值、移动和销毁的？类通过一些特殊的成员函数控制，包括：拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符以及析构函数。

当定义一个类时，我们显式地或隐式的指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：
**拷贝构造函数**（copy constructor），**拷贝赋值运算符**（copy-assignment operator）、**移动构造函数**（move constructor）、*
*移动赋值运算符**（move-assignment operator）和**析构函数**（destructor）。

拷贝和移动构造函数定义了当用同类型的另一个对象**初始化**本对象时做什么；拷贝和移动赋值运算符定义了将一个对象**赋予**
同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为**拷贝控制操作**（copy control）。

如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它补全缺失操作。但是对于某些类来说，以来自动补全地默认操作会导致问题。

在定义任何C++类时，拷贝控制操作都是必要部分。

## 拷贝、赋值与销毁

### 拷贝构造函数

**拷贝构造函数定义了当用同类型的另一个对象** ***初始化*** **新对象时做什么**。

如果一个构造函数的第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数时拷贝构造函数。

```cpp
class Function{
	public:
		Function(); // 默认构造函数
		Function(const Function &); // 拷贝构造函数
}
```

**拷贝构造函数的第一个参数必须是一个引用类型**。拷贝在几种情况下都会被隐式使用，因此拷贝构造函数通常不应该是explicit的。

对某些类来说，**合成拷贝构造函数**（synthesized copy
constructor）用来阻止我们拷贝该类类型的对象。一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。

每个成员的类型决定其如何拷贝：

- 对类类型成员，使用拷贝构造函数拷贝
- 对内置类型成员，直接拷贝
- 对数组类型，合成拷贝构造函数会逐个元素拷贝一个数组类型的成员

```cpp
string a(10,",");           // 直接初始化
string b(a);                // 直接初始化
string c = b;               // 拷贝初始化
string d = "123";           // 拷贝初始化
string e = string(1,"a");   // 拷贝初始化
```

当使用直接初始化，实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。

> 函数匹配（重载确认）：指一个过程，在这个过程中将函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。

当使用拷贝初始化时，编译器将右侧运算符对象拷贝到正在创建的对象中，如果需要进行类型转换。拷贝初始化通常用拷贝构造函数完成。但如果类有移动拷贝函数，那么拷贝初始化有时会使用移动拷贝函数。

拷贝初始化发生情况：

- 用“=”定义变量时
- 将一个对象作为实参传递给一个非引用类型的形参时
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

某些类类型还会对它们所分配的对象进行拷贝初始化。例如：初始化标准库容器或调用其insert或push成员。注意到的是emplace成员创建的元素都进行直接初始化（emplace成员会直接在容器管理的内存空间中构造元素，而非像push_back般创建一个局部临时对象并压入容器中）。

> 聚合类：
> - 所有成员都是public的
> - 没有定义任何构造函数
> - 没有类内初始值
> - 没有基类，也没有virtual类
>
> 如：
>
> ```cpp
> struct Data{
>   int ival;
>   string s;
> }
> ```
> 初始化可以写成：`Data val={0,"A"};`，初始化顺序必须与声明顺序一致

#### 参数和返回值

拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果不是，那么将陷入死循环，调用永远不会成功。🤯

#### 拷贝初始化的限制

拷贝初始化一般要求构造函数不使用explicit，如果使用，那么是否是用拷贝初始化还是直接初始化显得无关紧要：

```cpp
vector<int> v1(10); // ok
vector<int> v2 = 10; //false 因为构造函数为explicit
void f(vector<int>); // ok
void f(10); // false
void f(vector<int>(10)); // ok
```

#### 编译器可以绕过拷贝构造函数

拷贝初始化时，编译器可以（不是必须）跳过拷贝/移动构造函数，直接创建对象：

```cpp
string a = "a";
// 改写为：
string b("a"); // 编译器略过拷贝构造函数
```

虽然编译器可以略过，但是在此节点的拷贝/移动构造函数必须存在且可访问（即不是private）。

### 拷贝赋值运算符

**拷贝赋值运算符定义将一个对象** ***赋予*** **同类型的另一个对象时做什么**。

类可以通过**拷贝赋值运算符**控制对象如何赋值，同拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会自动合成。

#### 重载赋值运算符

重载运算符（overloaded operator）本质上是函数，其名字由operator关键字和要定义的运算符符号组成。类似其他函数，运算符函数也有一个返回类型和一个参数列表。

如果一个运算符是一个成员函数，其左侧运算对象绑定到隐式this参数，对于一个二元运算符，其右侧运算对象作为显式参数传递。

**拷贝赋值运算符接受一个与其所在类相同类型的参数**。

```cpp
Function& operator=(const Function&);
```

为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向左侧运算对象的引用。同时标准库通常要求保存在容器中的类型具有赋值运算符，其返回值是左侧的引用。所以，在
**设计赋值运算符时通常应该返回一个指向其左侧对象的引用**。

#### 合成拷贝赋值运算符

**合成拷贝赋值运算符**（synthesized copy-assignment
operator）。与合成拷贝构造函数类似：对于某些类，合成拷贝赋值运算符用来禁止该类型的对象的赋值（因为隐式生成的拷贝构造和赋值可能是delete的）。

拷贝赋值运算符会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作通过成员类型的拷贝赋值运算符来完成。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

```cpp
Sales_data& 
Sales_data::operator=(const Sales_data &rhs){
	bookNo = rhs.bookNo;
	units_sold = rhs.units_sold;
	revenue = rhs.revenue;
	return *this;
}
```

#### 析构函数

析构函数执行与构造函数相反的操作：

- 构造函数：初始化对象的非static数据成员，做一些其他工作
- 析构函数：释放对象使用的资源，并销毁对象的非static数据成员

析构函数作为类的成员函数，函数名由波浪号“~”和类名组成，不接受返回类型和参数。

```cpp
class A{
	~A(){
		//……
	};
}
```

> 析构函数不接受参数，所以不支持重载。一个给定类仅存在唯一析构函数

在构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员（成员按照初始化顺序的
**逆序**销毁）。

析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数；销毁内置类型什么也不需要做。

> 隐式销毁一个内置指针类型成员并不会delete它所指向的对象。
>
> 但是销毁智能指针，智能指针是类类型，有自己的析构函数。

无论何时一个对象被销毁，就会自动调用其析构函数：

- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete时被销毁
- 对临时对象，当创建它的完整表达式结束时被销毁

```cpp
{
	Sales_data *p = new Sales_data; // 内置指针
	auto p_2 = make_shared<Sales_data>(); // shared_ptr
	Sales_data p_3(*p);
	vector<Sales_data> vec; // 局部变量
	vec.push_back(*p_2);
	delete p; 
}   // 对 p_2、p_3和vec调用析构函数
	// 销毁p_2会递减其引用计数
	// 销毁vec会销毁其元素
```

同样，如果类未定义自己的析构函数，编译器会生成**合成析构函数**。

> 认识到析构函数的函数体自身并不直接销毁成员非常重要。成员是在析构函数体之后隐式的析构阶段被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

### 三/五原则

在上述介绍了三个控制类拷贝的基本操作：拷贝构造函数，拷贝赋值运算符和析构函数，还剩下移动构造函数和移动赋值运算符没有讲。通常来讲这些操作应该被看作是一个整体。

**需要析构函数的类也需要拷贝和赋值操作**

当我们决定一个类是否需要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比拷贝构造函数或赋值运算符的需求更为明显。
**如果这个类需要一个析构函数，几乎可以肯定的是它也需要一个拷贝构造函数和一个拷贝赋值函数**。

**需要拷贝操作的类也需要赋值操作，反之亦然**，但是无论是需要拷贝构造函数还是需要拷贝赋值函数都**不必然**需要析构函数。

### 使用=default

可以通过将拷贝控制成员定义为=default来显式要求编译器生成合成的版本。

类内使用=default则隐式声明为内联。

> 只能对具有合成版本的成员函数使用=default，即默认构造函数和拷贝控制成员。

### 阻止拷贝

对于某些类来说，拷贝控制操作没有意义，那么必须采用某种机制阻止拷贝或赋值。例如：iostream类。

**定义删除的函数**

C++11标准下可以对拷贝构造函数和拷贝赋值运算符定义**删除的函数**（delete function），表明虽然声明了它，但是无法使用。

```cpp
struct NoCopy{
	NoCopy() = default;
	NoCopy(const NoCopy&) = delete;
	NoCopy &operator=(const NoCopy&) = delete;
	~NoCopy() = default;
}
```

与=default不同点：

1. =delete必须出现在函数第一次声明时。因为，可以直到生成代码时才需要=default，但是编译器必须一开始就知道=delete这个函数是被删除的。
2. 可以对任何函数指定=delete。

**析构函数不能是删除的成员**

对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时变量。

> 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。

对于删除了析构函数的类型，虽然不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但不能释放这些对象：

```cpp
struct NoDtor{
	NoDtor() =default;
	~NoDtor() = delete;
};
NoDtor nd; // false
NoDtor *p = new NoDtor(); // true
delete p; // false
```

**合成的拷贝控制成员可能是删除的**

- 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
- 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的

本质上，这些规则的含义是：当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。

一个成员有删除或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。因为可能会创建出无法销毁的对象。

**private拷贝控制**

通过声明private的拷贝控制函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。

> 使用现代C++时，希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的。

## 13.2 拷贝控制和资源管理

通常，管理类外资源的类必须定义拷贝控制成员。

类型对象的拷贝语义通常为两种：一种看起来像一个值，一种看起来像一个指针。

- 类的行为像一个值，意味着它有自己的状态。当拷贝一个像值的对象时，副本与原对象**完全独立**。例如：标准库容器、string类等
- 类的行为像一个指针，指针类为**共享状态**。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。例如：shared_ptr类等








