# 第十三章 拷贝控制

## 前言

类是如何控制类型对象的拷贝、赋值、移动和销毁的？类通过一些特殊的成员函数控制，包括：拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符以及析构函数。

当定义一个类时，我们显式地或隐式的指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：
**拷贝构造函数**（copy constructor），**拷贝赋值运算符**（copy-assignment operator）、**移动构造函数**（move constructor）、*
*移动赋值运算符**（move-assignment operator）和**析构函数**（destructor）。

拷贝和移动构造函数定义了当用同类型的另一个对象**初始化**本对象时做什么；拷贝和移动赋值运算符定义了将一个对象**赋予
**同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为**拷贝控制操作**（copy control）。

如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它补全缺失操作。但是对于某些类来说，以来自动补全地默认操作会导致问题。

在定义任何C++类时，拷贝控制操作都是必要部分。

## 拷贝、赋值与销毁

### 拷贝构造函数

如果一个构造函数的第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数时拷贝构造函数。

```cpp
class Function{
	public:
		Function(); // 默认构造函数
		Function(const Function &); // 拷贝构造函数
}
```

**拷贝构造函数的第一个参数必须是一个引用类型**。拷贝在几种情况下都会被隐式使用，因此拷贝构造函数通常不应该是explicit的。

对某些类来说，**合成拷贝构造函数**（synthesized copy
constructor）用来阻止我们拷贝该类类型的对象。一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。

每个成员的类型决定其如何拷贝：

- 对类类型成员，使用拷贝构造函数拷贝
- 对内置类型成员，直接拷贝
- 对数组类型，合成拷贝构造函数会逐个元素拷贝一个数组类型的成员

```cpp
string a(10,",");           // 直接初始化
string b(a);                // 直接初始化
string c = b;               // 拷贝初始化
string d = "123";           // 拷贝初始化
string e = string(1,"a");   // 拷贝初始化
```

当使用直接初始化，实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。

> 函数匹配（重载确认）：指一个过程，在这个过程中将函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。

当使用拷贝初始化时，编译器将右侧运算符对象拷贝到正在创建的对象中，如果需要进行类型转换。拷贝初始化通常用拷贝构造函数完成。但如果类有移动拷贝函数，那么拷贝初始化有时会使用移动拷贝函数。

拷贝初始化发生情况：

- 用“=”定义变量时
- 将一个对象作为实参传递给一个非引用类型的形参时
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

某些类类型还会对它们所分配的对象进行拷贝初始化。例如：初始化标准库容器或调用其insert或push成员。注意到的是emplace成员创建的元素都进行直接初始化（emplace成员会直接在容器管理的内存空间中构造元素，而非像push_back般创建一个局部临时对象并压入容器中）。

> 聚合类：
> - 所有成员都是public的
> - 没有定义任何构造函数
> - 没有类内初始值
> - 没有基类，也没有virtual类
>
> 如：
>
> ```cpp
> struct Data{
>   int ival;
>   string s;
> }
> ```
> 初始化可以写成：`Data val={0,"A"};`，初始化顺序必须与声明顺序一致

#### 参数和返回值

拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果不是，那么将陷入死循环，调用永远不会成功。🤯

#### 拷贝初始化的限制

拷贝初始化一般要求构造函数不使用explicit，如果使用，那么是否是用拷贝初始化还是直接初始化显得无关紧要：

```cpp
vector<int> v1(10); // ok
vector<int> v2 = 10; //false 因为构造函数为explicit
void f(vector<int>); // ok
void f(10); // false
void f(vector<int>(10)); // ok
```

#### 编译器可以绕过拷贝构造函数

拷贝初始化时，编译器可以（不是必须）跳过拷贝/移动构造函数，直接创建对象：

```cpp
string a = "a";
// 改写为：
string b("a"); // 编译器略过拷贝构造函数
```

虽然编译器可以略过，但是在此节点的拷贝/移动构造函数必须存在且可访问（即不是private）。

