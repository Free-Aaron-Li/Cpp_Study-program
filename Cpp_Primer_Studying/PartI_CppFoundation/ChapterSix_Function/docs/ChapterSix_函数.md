# 第六章 函数

## 前言

何谓函数？

函数就是命了名的代码块😄。通过调用函数执行对应代码，实现目标效果。函数可以通过重载的方式，实现同一个名字多种实现。

介绍：

- 函数的定义
- 函数的声明
- 重载函数
- 编译器如何选择与之匹配的函数版本

---

## 6.1 函数基础

典型的函数：

```cpp
void test(int n){
    /* ... */
}

int main(){
    int x;      /* 实参 */
    test(x);    /* 调用函数 */
    return 0;   /* 返回值 */
}
```

`void`，返回类型（return type）；`test`函数名；`(int n)`，括号内存放形参（parameter），一个函数可以有0个或多个形参；`{}`
，函数体（function body）。

通过使用**调用运算符**（call
operator）来执行函数。调用运算符形式为一对括号，其作用于一个表达式（可以是函数也可以是指向函数的指针）；括号内用于存放实参（argument）列表，用于初始化函数的形参。调用表达式的类型就是函数的返回类型。

#### 函数调用

函数调用有两项任务：

- 实参初始化函数对应的形参
- 将控制权转移给被调函数

在函数中，return语句也有两项任务：

- 返回return语句中的值（如果有）
- 将控制权从被调函数转移到主调函数

函数的返回值一般用于初始化调用表达式的结果。

#### 形参和实参

- 实参是形参的初始值
- 没有规定实参的求值顺序，所以编译器能够以任意可行顺序对实参求值
- 实参的类型必须与形参类型匹配（不一定一致）
- 实参的数量必须与形参数量一致

#### 函数形参列表

函数的形参列表可以为空，但不能没有。😀

```cpp
/* 隐式定义空形参列表 */
void test_1(){ /* ... */}

/* 显式定义空形参列表 */
void test_2(void){/* ... */}
```

在通常情况下，直接写一个空的空格表示空形参列表。当然，为了与C语言兼容，也可以写一个void显式定义空形参列表。

每个形参都是含有一个声明符的声明，所以哪怕两个形参类型一致，都需要分开写出来。当然也保证每个形参名字都是独一无二的，且函数最外层作用域中的局部变量也不能和函数形参名一致。

```cpp
void test_3(int a,int b){ /* ... */}
```

#### 函数返回类型

如果返回类型为void，则表示不返回任何值。

函数无法返回数组类型或函数类型，但是可以返回数组指针或函数指针。

### 局部对象

> 补充
>
> 名字有作用域，对象有生命周期。
>
> - 名字的作用域是程序文本的一部分，名字在其中可见。
> - 对象的生命周期是程序执行过程中该对象存在的一段时间。

函数体本质上是一个语句块，其自构成一个作用域。形参和函数体内定义的变量称为*局部变量*（local
variable）。局部变量自身具有“隐藏性”，对局部变量而言，在外层作用域的同名的所有声明都是隐藏的。

关于局部变量的生命周期，其依赖于定义方式。

#### 自动对象

对当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。只存在与块执行期间的对象称为*自动对象*
（automatic object）。当块执行结束后，块中创建的自动对象的值就变成未定义的。

对于局部变量对应的自动对象来说，分为两种情况：

- 如果变量定义本身含有初始值，就使用该初始值初始化
- 如果变量定义不含初始值，执行默认初始化

那么存在这种情况：内置类型的未初始化局部变量就会产生未定义的值。

![内置类型-未定义](https://s3.bmp.ovh/imgs/2023/06/09/8ddbc126accc5ad1.png)

#### 局部静态变量

对于哪些希望函数结束，函数内定义的变量依旧有效，那么便可以使用*局部静态对象*（local static object）。

如果局部静态变量没有显式的初始值，那么该对象将执行值初始值。

### 函数声明

函数名字必须在使用前声明（这似乎是常理😉）。

函数的声明用于函数的定义类似，唯一区别在于函数无需函数体，用分号代替。

函数声明可以不用写形参的名字（笔者我之前就经常忽略形参的名字，但这并不是个好习惯。现在使用CLion编写时，一般编写函数声明，再由CLion自动生成函数定义头部）。但是，写上形参的名字还是有好处的，它可以帮助使用者更好地理解函数的功能。

**函数三要素**:

- 返回类型
- 函数名
- 形参类型

函数的三要素已经就可以描述函数的接口了，能够说明该函数所需的全部信息。因此，函数声明也被称为*函数原型*（function prototype）。

#### 在头文件中进行函数声明

函数声明应该存放在头文件中，同时函数定义应该在源文件中。

*含有函数声明的头文件应该被包含到定义函数的源文件中*。

### 分离式编译

分离式编译（separate compilation），其编译允许我们把程序分割到几个文件中去，每个文件独立编译。

这里使用Linux平台下的GCC下的g++（GUN C++ Compiler）编译器完成分离式编译：

首先创建三个文件：`fact.cpp`、`factMain.cpp`和`Chapter6.hpp`，`fact.cpp`文件用于存放fact函数的定义;`factMain.cpp`
文件用于存放main函数并调用fact函数；`Chapter6.hpp`文件用于存放fact函数声明和导入iostream库。

下面给出文件内容：

Chapter6.hpp

```cpp
#ifndef CHAPTER6_HPP
#define CHAPTER6_HPP

#include <iostream>

int fact(int value);

#endif // !CHAPTER6_HPP
```

fact.cpp:

```cpp
#include "Chapter6.hpp"

int fact(int value){
  return value;
}
```

factMain.cpp:

```cpp
#include "Chapter6.hpp"
#include <cstdlib>
#include <iostream>

int main(){
  int value=10;
  std::cout<<fact(value)<<"\n";
}
```

编译过程：

①、使用g++编译器编译fact.cpp和factMain.cpp生成中间代码文件：

```bash
$ g++ -c fact.cpp && g++ -c factMain.cpp
```

②、使用g++将中间代码文件链接在一起形成可执行文件：

```bash
$ g++ fact.o factMain.o -o main
```

③、执行可执行文件，得到结果：

```bash
$ ./main
10
```

这个时候，查看当前文件夹下，应该存在如下文件：

```bash
$ ls
Chapter6.hpp  fact.cpp  factMain.cpp  factMain.o  fact.o  main*
```

其中，`.hpp`表示C++头文件，`.cpp`表示C++源文件，`.o`表示Linux平台下的中间代码文件（Windows下为`.obj`），`mian*`
表示Linux平台下的可执行文件（Windows下为`.exe`）

## 参数传递

形参初始化的机理和变量初始化一致。

形参的类型决定了形参和实参交互的方式。如果形参是引用类型，那么它将被绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。

由此，我们可以说如果形参是引用类型，那么其对应的实参被*引用传递*（passed by reference）或者说函数被*传引用调用*（called by
reference）。如果实参的值被拷贝给形参，那么说这样的实参被*值传递*（passed by value）或者函数被*传值调用*（called by value）。

### 传值参数

在之前我们使用变量的初始化时，如果不使用引用类型的变量，其初始化仅是将变量值拷贝给被初始化对象，其本身并未变化。

```cpp
int i=10;
int j=i;
j=1;    /* j的值发生改变，为1，但是i的值并未改变。*/
```

传值参数类似，函数对形参所做的所有操作并不会影响到实参。

#### 指针形参

指针的行为和其他非引用类型一致。当执行指针拷贝操作时，拷贝的是指针的值（也就是指针指向对象的地址）。拷贝后，两个指针是不同的指针。

```cpp
void reset(int *ip){
    *ip=0;  /* 指针所指向的对象值改为0 */
    ip=0;   /* 仅能改变ip的局部拷贝，其实参并未发生改变 */
}


int main(){
    int i=42;
    reset(&i);      /* 改变的是i的值，i的地址并未改变 */
    cout<<i<<endl;  /* 输出0 */
```

> 补充
>
> 对于熟悉C的程序员来说，其常常使用指针类型的形参来访问函数外部的对象。建议在C++中，使用引用类型的指针来代替指针。


