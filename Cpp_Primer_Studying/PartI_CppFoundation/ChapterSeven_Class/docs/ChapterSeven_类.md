# 第七章 类

## 前言

基本数据类型有时候并不能解决某些特定问题，而通过自定义的类就可以通过理解问题概念，使得程序更加容易编写、调试和修改。

类的基本思想是**数据抽象**（data abstraction）和**封装**（encapsulation）。 数据抽象是一种依赖于**接口**（interface）和**实现**
（implementation）分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

可以说，封装实现了类的接口和实现的分离。封装后的类隐藏类它的实现细节。

介绍：

- 定义抽象数据类型
- 访问控制与封装
- 类其他特性及作用域
- 构造函数
- 类静态成员

---

## 7.1 定义抽象数据类型

### 设计Sales_data类

其类接口包括：

- 一个isbn成员函数，用于返回对象的ISBN编号
- 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上
- 一个add函数，执行两个Sales_data对象的加法
- 一个read函数，将数据从istream中读入到Sales_data对象中
- 一个print函数，将Sales_data对象的值输出到ostream

> 开发
>
> 优秀的类设计者除了充分了解并实现用户的需求，还应该密切关注哪些有可能使用该类的程序员的需求。
>
> 一个设计良好的类，既要有易于使用的接口，也必须具备高效的实现过程。

> 注意
>
> 定义在类内部的函数是隐式的inline函数

### 定义改进的Sales_data类

定义成员函数

所有类成员必须在类内部声明，但是可以自由选择在类内或类外定义。

this使用

当我们调用成员函数时，实际上是**替**某个对象调用它。例如：

```cpp
/* 某个成员函数 */
std::string isbn() const { return bookNo; }
```

当我们调用isbn成员函数时，返回的bookNo数据成员，那么其隐式的返回的应该是total.bookNo（假设该函数的对象为total）。可以这样理解：使用this是将对象作为一个整体访问，而非直接访问对象的某个成员。

成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如：

```cpp
/* 如果调用 */
total.isbn();
/* 编译器将会把total的地址传递给isbn的隐式形参this,等价于下面这个伪代码 */
Sales_data::isbn(&total);
```

> 注意
>
> 在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符，因为this所指的正是这个对象。任何对类成员的直接访问都被看作this的隐式引用。
>
> 因为this的目的总是指向“这个”对象，所以this是一个常量指针。


引入const成员函数

在成员函数中，存在这种写法：

```cpp
std::string isbn() const {return bookNo};
```

其中，const关键字作用于修改隐式this指针的类型。

在默认情况下，this的类型是指向类类型非常量版本的常量指针。对使用这种const方式的函数成为常量成员函数（const member
function）。

我们可以将上述写法想象成：

```cpp
std::string Sales_data::isbn(const Sales_data * const this){
    return this->bookNo;
}
```

类作用域和成员函数

**类本身就是一个作用域，类的成员函数的定义嵌套在类的作用域之内**。

如果在类的外部定义成员函数，其定义必须与它的声明匹配，同时外部定义的成员的名字必须包含它所属的类名。

定义一个返回this对象的函数

### 定义类相关的非成员函数

类作者常常需要定义一些辅助函数，例如：add、read、print等等。这些辅助函数从概念上讲属于是类的接口的一部分，但是实际上其并不属于类。虽然实际上不属于类，但是概念上属于，所以一般将这些非成员函数写在同一个头文件中。

### 构造函数

构造函数（constructor）用于初始化类对象的数据成员，无论何时只要类被创建，就会执行构造函数。

构造函数名字与类名相同，与其他函数不同的是，构造函数没有返回类型；同时类可以包含多个构造函数，但是与重载函数不同的是，构造函数之间必须在参数列表或者参数类型上有所区别；同时构造函数不能被声明为const。

当我们没有显式声明并定义构造函数，那么类将会通过一个**默认构造函数**（default constructor）来控制默认初始化过程。编译器创建的构造函数同时又被称为
**合成的默认构造函数**（synthesized default constructor）。但是合成的默认构造函数仅适合非常简单的类，对于一个普通的类，必须定义一个它自己的默认构造函数，因为：

1. 编译器只有在类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。
2. 含有内置类型或者复合类型成员的类在类的内部初始化时采用默认初始化很有可能其初始化值为未定义的。
3. 有些时候编译器并不能为某些类合成默认的构造函数。

这里，使用一个示例进行分析：

```cpp
SalesData()=default;        /* 默认构造函数，希望这个函数的作用等同于合成默认构造函数 */
SalesData(const std::string &str):_bookNo(str){}
SalesData(const std::string &str,unsigned number,double price):_bookNo(str),_units_sold(number),_revenue(price*number){}
SalesData(std::istream &);
```

`=default`，在C++标准中，使用`SalesData()=default;`
方式要求编译器生成构造函数。该定义既可以在声明处，也可以在类外部。与其他函数一致，如果在类内部，则默认为内联方式，如果在类外部，默认不使用内联方式。

构造函数初始值列表

首先我们可以看看后两个定义的构造函数，在冒号和大括号之间存在的部分成为**构造函数初始值列表**（constructor initialize
list）。其负责为新创建的对象的一个或者几个数据成员赋初值。如果某个数据成员被构造函数初始值列表忽略，那么其将会以合成默认构造函数相同的方式初始化。

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在那么我们就确保了为成员赋予了一个正确的值。但是，如果编译器不支持类内初始值，那么所有的构造函数都应该显式地初始化每一个内置类型的成员。

在类的外部定义构造函数

构造函数没有返回类型，同时在类外部定义构造函数时必须明确构造函数是哪个类的成员。

### 拷贝、赋值和析构

在实际开发中，我们除了需要知道如何对对象进行初始化，还需要知道如何控制拷贝、赋值和销毁对象时发生的行为。

拷贝操作常见于：初始化变量并且采用值传递方式或者返回一个对象；赋值操作见于使用赋值运算符时发生对象的赋值操作；销毁对象，常见的示例比如：当我们将vector对象销毁时，其存储的对象也一并被销毁。

如果，我们不主动控制或者说是定义这些操作，那么编译器将会替我们合成它们。

但是，某些类其实不能够依赖于合成的版本，我们更加希望自定义这些操作。这些知识需要到第13章进行详细描述。

## 7.2 访问控制与封装

在我们之前对Sales_data类进行编写时，我们并没有任何机制强制使用我们在该类中写下的接口，用户可以随时的直达Sales_data类的内部并控制其具体实现细节。也就是说，该类还没有被
**封装**。

没有对类进行封装其内部细节相当于直接暴露出来，这是不安全的！。所以，在C++中，我们可以通过使用**访问说明符**（access
specifiers）加强类的封装：

- 定义在**public**说明符之后的成员在整个程序中都是可以被访问的，例如：public定义类的接口
- 定义在**private**说明符之后的成员仅可以被类的成员函数访问，所以private封装了类的部分实现细节。

常用的格式是：

    部分成员函数和构造函数在public说明符之后，而数据成员和作为实现部分的函数则在private说明符之后。

一个类可以存在0个或者多个访问说明符，每个访问说明符指定了接下来的成员的访问级别，其有效范围知道出现下一个访问说明符或者类的结尾为止。

> 补充
>
> 使用class和struct关键字，二者均是用于表示类的定义，其唯一区别就是对默认访问权限的不同。
>
> 类可以在其出现第一个访问说明符之前定义成员，这些成员的访问权限依赖于类定义的方式。如果是struct，则默认权限为public，如果是class，则默认权限为private。

### 友元

如果想要其他类或者函数访问某个类的非公有成员，只需要令其他类或者函数成为这个类的**友元**（friend）即可。

例如，如果想要把某个函数作为这个类的友元，只需要在该类中增加一条以friend关键字开始的函数声明语句即可。


> 注意
>
> 友元的声明仅仅指定了访问的权限，并不是一个通常意义的声明。所以，如果希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。也就是说，除了在类的内部进行友元声明，在类的外部也需要提供独立的函数声明。
>
> 但是一些编译器允许在没有友元函数的初始声明的情况下调用函数，但是最好的情况下还是提供一个独立的函数声明。

> 建议
>
> 虽然友元只能声明在类定义的内部，但是友元的出现在类内部的位置是不限的。同时友元不是类的成员所以也不受其所在区域的访问控制级别的约束。但是，建议最好是在类定义开始或者结束前的位置声明友元，保证类内部的成员位置的整齐。

> 补充
>
> 封装的好处
>
> 封装的两个重要的优点：
>
> - 保证用户代码不会修改、删除等操作封装对象中的内容
> - 被封装的类，其具体实现细节可以随时改变，而无须调整用户级别的代码
>
> 一旦把数据成员定义成private的，类的作者就可以比较自由地修改数据了。当实现部分改变时，我们只需要检查类的代码本身以确定这次改变有什么影响；也就是说，只要类的接口不变，用户代码就无需改变。
>
> 如果数据是public的，则所有使用了原来数据成员的代码都有可能失效（例如，我们在前面编写的练习7.3
> ，如果我们将Sales_data中的数据成员设定为private的，那么将会报出许多错误，需要一个个修改），
> 这时我们必须定位并且重写所有依赖于老版本实现的代码，之后才能重新使用该程序。
>
> 把数据成员的访问权限设成private还有一个益处，这么做能够防止用户的原因造成数据被破坏。如果我们
> 发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷：因为只要实现部分的代码可能产生这
> 样的错误。因此，将差错限制在有限范围内将能够极大地降低维护代码及修正程序错误的难度。

## 7.3 类的其他特性

在前面的章节我们基本上完成了Sales_data类，也了解和学习类一些类的特性，但是还有一些特性还没有从Sales_data类中体现出来。所以，接下来我们将了解类的其他特性，例如：类型成员、类的成员的类内初始值、可变数据成员、内联成员函数、从成员函数返回*
this、关于如何定义并使用类类型及友元类的更多知识。

在此之前，为了展示类的其他特性，我们创建一对相互关联的类，分别是Screen和Window_manager

### 类成员再探

Screen类用于表示显示器的一个窗口。每个Screen包含一个保存Screen内容的string成员和三个string::
size_type类型的成员，用于表示光标的位置以及屏幕的宽高。

这里，写下完整的Screen类：

```cpp
class Screen {
 public:
    typedef std::string::size_type pos;

 public:
    Screen() = default;
    Screen(pos height, pos width, char c) : _height(height), _width(width), _contents(height * width, c) {}

 public:
    char    get() const { return _contents[_cursor]; } /* 读取光标处的字符 */
    char    get(pos height, pos width) const;
    Screen& move(pos height, pos width);               /* 移动光标 */

 private:
    /* 光标位置 */
    pos         _cursor = 0;
    pos         _height = 0, _width = 0;
    /* 保存Screen内容 */
    std::string _contents;
};

inline Screen& Screen::move(Screen::pos height, Screen::pos width) {
    pos row = height * _width;
    _cursor = row + width;
    return *this;
}

inline char Screen::get(Screen::pos height, Screen::pos width) const {
    Screen::pos row = height * _width;
    return _contents[row + width];
}
```

类可以自定义某种类型在类中别名（且同样具有访问控制）。

同时，在写Screen类时需要注意：用来定义类型的成员必须先定义后使用。

想要使得我们的Screen类更加实用，则需要添加构造函数使得用户能够自定义屏幕的尺寸和内容，同时需要两个成员函数来负责移动光标和读取给定位置的字符。

#### 内联函数再探

定义在类内中的成员函数都是自动inline的，但这些成员函数规模一般比较小。例如：用来作为返回数据成员值。

同时，除了可以在类内进行隐式内联外，还可以进行显式内联：

```cpp
char    get() const { return _contents[_cursor]; }  /* 隐式内联 */
inline char    get(pos height, pos width) const;    /* 显式内联 */
```

对于某些函数规模较大，我们可以在类外进行成员函数定义，那么可以通过inline关键字修饰类外定义的成员函数。

虽然我们无须在类内和类外同时说明inline，但是这是合法的。同时，建议在类外成员函数的定义处说明inline，这样便于类的理解。

> 建议
>
> 成员函数应该与相应的类定义在同一个头文件中。

#### 成员函数的重载

成员函数的重载与非成员函数一致，只需要函数之间在参数和/或者类型上有所区别即可。例如，在Screen函数中的两个get()函数。

#### 可变数据成员

存在这种情况，我们希望能够修改某个数据成员，即便是在一个const成员函数内。那么我们可以通过关键字**mutable**。

一个**可变数据成员**（mutable data member)永远都不会是const，即便是作为const对象的成员。示例：

```cpp
public:
void    some_member() const;

private:
mutable size_t _access_times; /* Screen的成员函数被调用次数 */

inline void Screen::some_member() const { ++_access_times; }

```

虽然some_member函数是一个const成员函数，但是其仍然能够改变_access_times成员的值。

#### 类数据成员的初始值

在完成Screen类后，我们希望存在一个类用于管理窗口，所以我们设定一个Window_manager类，该类存在一个vector，用于包含Screen。当然在默认情况下，我们希望存在一个默认的Screen。在C++11标准下，最好的方式是将这个默认值声明成一个类内初始值。

```cpp
class Window_manager {
 private:
    std::vector<Screen> screens{Screen(24, 80, ' ')};
};
```

> 注意
>
> 当我们提供一个类内初始值时，必须以符号=或者大括号表示。

### 返回*this的成员函数

```cpp
Screen& Screen::set(Screen::pos height, Screen::pos width, char character) {
    _contents[height * _width + width] = character;
    return *this;
}

inline Screen& Screen::move(Screen::pos height, Screen::pos width) {
    pos row = height * _width;
    _cursor = row + width;
    return *this;
}

myScreen.move(4,0).set('#');
```

在我们定义set()函数时其返回值是调用set的对象的引用。返回引用的函数是左值的，意味着**函数返回的是对象本身而非对象的副本**
。假如我们定义的返回类型不是引用，那么move的返回值将会是*this的副本，那么调用set只能临时改变副本，并不能改变myScreen的值。

#### 基于const的重载

通过区分成员函数是否是const的，我们可以进行重载。存在一种情况，非常量版本的函数对常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或者非常量版本，但是显然此时非常量版本是一个更好的匹配。

例如，display函数，我们通过定义一个do_display的私有成员，由它负责打印Screen操作（保证安全性），重载display函数，实现常量版本和非常量版本。

```cpp
class Screen{
 public:
    Screen&       display(std::ostream& ostream);
    const Screen& display(std::ostream& ostream) const;

 private:
    void do_display(std::ostream& ostream) const { ostream << _contents; }

}

inline Screen& Screen::display(std::ostream& ostream) {
    do_display(ostream);
    return *this;
}
inline const Screen& Screen::display(std::ostream& ostream) const {
    do_display(ostream);
    return *this;
}

/* ****************** */

Screen myScreen(5,3);
const Screen replica(5,3);
myScreen.set('#').display(cout);        /* 调用非常量版本 */
blank.display(cout);                    /* 调用常量版本 */
``` 

当一个成员调用另一个成员时，this指针在其中隐式地传递。当display调用do_display时，它的this指针隐式地传递给do_display。而当display的非常量版本调用do_display时，他的this指针将隐式得从指向非常量的指针转换为指向常量的指针。

而当do_display完成后，display函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此display返回一个普通引用；而const成员返回一个常量引用。

也就是说，我们将do_display封装起来，不影响display的工作。

> 建议
>
> 对于公共代码使用私有功能函数
>
> 原因：
>
> - 避免在多出使用同样的代码
> - 随着预期发展，公共代码可能愈加复杂，那么将操作进行模块化处理显得非常有必要
> - 在某些时候，为某些模块添加调试信息，那么在最终版本中，对于调试信息的位置有个明确的概念
> - 通过使用内联的方式，额外的函数调用不会增加任何开销
> - 出于安全考虑，隐藏实现细节

### 类类型

**每个类定义类唯一的类型**。即便类与类之间的成员完全一致，类与类也是不同类型。

根据类的唯一性，我们就可以把类名作为类型的名字使用，从而直接指向类类型。

```cpp
Sales_data obj_1;
class Sales_data obj_2; /* 继承于C语言，等价于上一条 */
```

#### 类的声明

类似于函数的声明与定义可以分离，类也可以仅声明而暂时不定义它。

```cpp
class Screen;   /* 仅声明 */
```

这种声明称作**前向声明**（forward declaration），其仅向程序表明引入了名为Screen的类。对于该类类型来说，它在声明以后定义之前是一个
**不完全类型**（incomplete type），表明：我们已知Screen是一个类类型，但是不清楚其包含什么成员。

不完全类型的使用场景非常有限：

- 可以定义指向这种类型的指针或者引用
- 可以声明以不完全类型作为参数或者返回类型的函数，但是不能够定义。

对于编译器来说，只有定义了类类型，那么我们在创建这个类类型对象时才能够知道需要划分多少的存储空间。所以只有
**类被定义了，才能够使用引用或者指针访问其成员**。

额外情况：

```cpp
class Link_Screen{
    Screen window;      /* 必须Screen类被定义了，才能声明这种类类型 */
    Link_Screen *next;
    Link_Screen *prev; 
};
```

直到类被定义之后，数据成员才能被声明成这种类类型。也就是说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以
**一个类的成员类型不能是该类自己**。然而，一旦一个类的名字出现后，他就被认为是声明过了，因此
**类允许包含指向它自身类型的引用或者指针**。

### 友元再探

在之前，我们仅将定义类相关的非成员函数设定为友元，除此之外，还可以将其他类、其他类的成员函数定义为友元。当然，友元函数可以定义在类内部，这样的函数与上述的一致都是隐式内联的。

#### 类之间的友元关系

类之间的友元关系只需要在需要被访问的类中为提出类设定友元即可。例如，Window_manager类想要访问Screen类，则：

```cpp
class Screen{
    friend class Window_manager;
}
```

这样Window_manager成员就可以访问Screen类的私有部分。

总体上来说，如果一个类指定类友元类，那么友元类的成员函数就可以访问此类包括非公有成员在内的所有成员。

> 注意
>
> 友元关系不存在传递性，也就是说，如果Window_manager类有它自己的友元，但是这些友元没有访问Screen的特权。
>
> 每个类负责控制自己的友元类或者友元函数。

#### 令成员函数作为友元

当把一个成员函数声明为友元时，我们必须明确指出该成员函数属于哪个类。

但是需要注意的是，想要某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。所以，需要按照一下方法设计程序：

> 假设存在两个类：Window_manager和Screen，其中Window_manager类存在一个Clear函数，Clear函数想要成为Screen类的友元。

1. 首先需要定义Window_manager类，同时必须声明Clear函数，但是这个时候还不能定义它。在Clear函数使用Screen成员前必须先声明Screen类。（注意，Window_manager类必须写在Screen类前面）
2. 定义Screen类，包括对Clear的友元声明（所以建议友元写在类内的最前面）。
3. 定义Clear函数，这个时候该函数才能使用Screen中的成员。

#### 函数重载和友元

如果一个类想要将一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明（尽管重载函数名一致）。

#### 友元声明和作用域

类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地**假定**该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。

也就是说，就算是在类内部定义该函数，那么我们也必须在类外提供相应的声明从而使得函数可见。




