# 第七章 类

## 前言

基本数据类型有时候并不能解决某些特定问题，而通过自定义的类就可以通过理解问题概念，使得程序更加容易编写、调试和修改。

类的基本思想是**数据抽象**（data abstraction）和**封装**（encapsulation）。 数据抽象是一种依赖于**接口**（interface）和**实现**
（implementation）分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

可以说，封装实现了类的接口和实现的分离。封装后的类隐藏类它的实现细节。

介绍：

- 定义抽象数据类型
- 访问控制与封装
- 类其他特性及作用域
- 构造函数
- 类静态成员

---

## 7.1 定义抽象数据类型

### 设计Sales_data类

其类接口包括：

- 一个isbn成员函数，用于返回对象的ISBN编号
- 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上
- 一个add函数，执行两个Sales_data对象的加法
- 一个read函数，将数据从istream中读入到Sales_data对象中
- 一个print函数，将Sales_data对象的值输出到ostream

> 开发
>
> 优秀的类设计者除了充分了解并实现用户的需求，还应该密切关注哪些有可能使用该类的程序员的需求。
>
> 一个设计良好的类，既要有易于使用的接口，也必须具备高效的实现过程。

> 注意
>
> 定义在类内部的函数是隐式的inline函数

### 定义改进的Sales_data类

定义成员函数

所有类成员必须在类内部声明，但是可以自由选择在类内或类外定义。

this使用

当我们调用成员函数时，实际上是**替**某个对象调用它。例如：

```cpp
/* 某个成员函数 */
std::string isbn() const { return bookNo; }
```

当我们调用isbn成员函数时，返回的bookNo数据成员，那么其隐式的返回的应该是total.bookNo（假设该函数的对象为total）。可以这样理解：使用this是将对象作为一个整体访问，而非直接访问对象的某个成员。

成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如：

```cpp
/* 如果调用 */
total.isbn();
/* 编译器将会把total的地址传递给isbn的隐式形参this,等价于下面这个伪代码 */
Sales_data::isbn(&total);
```

> 注意
>
> 在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符，因为this所指的正是这个对象。任何对类成员的直接访问都被看作this的隐式引用。
>
> 因为this的目的总是指向“这个”对象，所以this是一个常量指针。


引入const成员函数

在成员函数中，存在这种写法：

```cpp
std::string isbn() const {return bookNo};
```

其中，const关键字作用于修改隐式this指针的类型。

在默认情况下，this的类型是指向类类型非常量版本的常量指针。对使用这种const方式的函数成为常量成员函数（const member
function）。

我们可以将上述写法想象成：

```cpp
std::string Sales_data::isbn(const Sales_data * const this){
    return this->bookNo;
}
```

类作用域和成员函数

**类本身就是一个作用域，类的成员函数的定义嵌套在类的作用域之内**。

如果在类的外部定义成员函数，其定义必须与它的声明匹配，同时外部定义的成员的名字必须包含它所属的类名。

定义一个返回this对象的函数

### 定义类相关的非成员函数

类作者常常需要定义一些辅助函数，例如：add、read、print等等。这些辅助函数从概念上讲属于是类的接口的一部分，但是实际上其并不属于类。虽然实际上不属于类，但是概念上属于，所以一般将这些非成员函数写在同一个头文件中。

### 构造函数

构造函数（constructor）用于初始化类对象的数据成员，无论何时只要类被创建，就会执行构造函数。

构造函数名字与类名相同，与其他函数不同的是，构造函数没有返回类型；同时类可以包含多个构造函数，但是与重载函数不同的是，构造函数之间必须在参数列表或者参数类型上有所区别；同时构造函数不能被声明为const。

当我们没有显式声明并定义构造函数，那么类将会通过一个**默认构造函数**（default constructor）来控制默认初始化过程。编译器创建的构造函数同时又被称为
**合成的默认构造函数**（synthesized default constructor）。但是合成的默认构造函数仅适合非常简单的类，对于一个普通的类，必须定义一个它自己的默认构造函数，因为：

1. 编译器只有在类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。
2. 含有内置类型或者复合类型成员的类在类的内部初始化时采用默认初始化很有可能其初始化值为未定义的。
3. 有些时候编译器并不能为某些类合成默认的构造函数。

这里，使用一个示例进行分析：

```cpp
SalesData()=default;        /* 默认构造函数，希望这个函数的作用等同于合成默认构造函数 */
SalesData(const std::string &str):_bookNo(str){}
SalesData(const std::string &str,unsigned number,double price):_bookNo(str),_units_sold(number),_revenue(price*number){}
SalesData(std::istream &);
```

`=default`，在C++标准中，使用`SalesData()=default;`
方式要求编译器生成构造函数。该定义既可以在声明处，也可以在类外部。与其他函数一致，如果在类内部，则默认为内联方式，如果在类外部，默认不使用内联方式。

构造函数初始值列表

首先我们可以看看后两个定义的构造函数，在冒号和大括号之间存在的部分成为**构造函数初始值列表**（constructor initialize
list）。其负责为新创建的对象的一个或者几个数据成员赋初值。如果某个数据成员被构造函数初始值列表忽略，那么其将会以合成默认构造函数相同的方式初始化。

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在那么我们就确保了为成员赋予了一个正确的值。但是，如果编译器不支持类内初始值，那么所有的构造函数都应该显式地初始化每一个内置类型的成员。

在类的外部定义构造函数

构造函数没有返回类型，同时在类外部定义构造函数时必须明确构造函数是哪个类的成员。

### 拷贝、赋值和析构

在实际开发中，我们除了需要知道如何对对象进行初始化，还需要知道如何控制拷贝、赋值和销毁对象时发生的行为。

拷贝操作常见于：初始化变量并且采用值传递方式或者返回一个对象；赋值操作见于使用赋值运算符时发生对象的赋值操作；销毁对象，常见的示例比如：当我们将vector对象销毁时，其存储的对象也一并被销毁。

如果，我们不主动控制或者说是定义这些操作，那么编译器将会替我们合成它们。

但是，某些类其实不能够依赖于合成的版本，我们更加希望自定义这些操作。这些知识需要到第13章进行详细描述。

## 7.2 访问控制与封装

在我们之前对Sales_data类进行编写时，我们并没有任何机制强制使用我们在该类中写下的接口，用户可以随时的直达Sales_data类的内部并控制其具体实现细节。也就是说，该类还没有被
**封装**。

没有对类进行封装其内部细节相当于直接暴露出来，这是不安全的！。所以，在C++中，我们可以通过使用**访问说明符**（access
specifiers）加强类的封装：

- 定义在**public**说明符之后的成员在整个程序中都是可以被访问的，例如：public定义类的接口
- 定义在**private**说明符之后的成员仅可以被类的成员函数访问，所以private封装了类的部分实现细节。

常用的格式是：

    部分成员函数和构造函数在public说明符之后，而数据成员和作为实现部分的函数则在private说明符之后。

一个类可以存在0个或者多个访问说明符，每个访问说明符指定了接下来的成员的访问级别，其有效范围知道出现下一个访问说明符或者类的结尾为止。

> 补充
>
> 使用class和struct关键字，二者均是用于表示类的定义，其唯一区别就是对默认访问权限的不同。
>
> 类可以在其出现第一个访问说明符之前定义成员，这些成员的访问权限依赖于类定义的方式。如果是struct，则默认权限为public，如果是class，则默认权限为private。

### 友元

如果想要其他类或者函数访问某个类的非公有成员，只需要令其他类或者函数成为这个类的**友元**（friend）即可。

例如，如果想要把某个函数作为这个类的友元，只需要在该类中增加一条以friend关键字开始的函数声明语句即可。


> 注意
>
> 友元的声明仅仅指定了访问的权限，并不是一个通常意义的声明。所以，如果希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。也就是说，除了在类的内部进行友元声明，在类的外部也需要提供独立的函数声明。
> 
> 但是一些编译器允许在没有友元函数的初始声明的情况下调用函数，但是最好的情况下还是提供一个独立的函数声明。

> 建议
>
> 虽然友元只能声明在类定义的内部，但是友元的出现在类内部的位置是不限的。同时友元不是类的成员所以也不受其所在区域的访问控制级别的约束。但是，建议最好是在类定义开始或者结束前的位置声明友元，保证类内部的成员位置的整齐。

> 补充
> 
> 封装的好处
> 
> 封装的两个重要的优点：
> 
> - 保证用户代码不会修改、删除等操作封装对象中的内容
> - 被封装的类，其具体实现细节可以随时改变，而无须调整用户级别的代码
> 
> 一旦把数据成员定义成private的，类的作者就可以比较自由地修改数据了。当实现部分改变时，我们只需要检查类的代码本身以确定这次改变有什么影响；也就是说，只要类的接口不变，用户代码就无需改变。
> 
> 如果数据是public的，则所有使用了原来数据成员的代码都有可能失效（例如，我们在前面编写的练习7.3，如果我们将Sales_data中的数据成员设定为private的，那么将会报出许多错误，需要一个个修改），这时我们必须定位并且重写所有依赖于老版本实现的代码，之后才能重新使用该程序。
>
> 把数据成员的访问权限设成private还有一个益处，这么做能够防止用户的原因造成数据被破坏。如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷：因为只要实现部分的代码可能产生这样的错误。因此，将差错限制在有限范围内将能够极大地降低维护代码及修正程序错误的难度。



