# 第七章 类

## 前言

基本数据类型有时候并不能解决某些特定问题，而通过自定义的类就可以通过理解问题概念，使得程序更加容易编写、调试和修改。

类的基本思想是**数据抽象**（data abstraction）和**封装**（encapsulation）。 数据抽象是一种依赖于**接口**（interface）和**实现**
（implementation）分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

可以说，封装实现了类的接口和实现的分离。封装后的类隐藏类它的实现细节。

介绍：

- 定义抽象数据类型
- 访问控制与封装
- 类其他特性及作用域
- 构造函数
- 类静态成员

---

## 7.1 定义抽象数据类型

### 设计Sales_data类

其类接口包括：

- 一个isbn成员函数，用于返回对象的ISBN编号
- 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上
- 一个add函数，执行两个Sales_data对象的加法
- 一个read函数，将数据从istream中读入到Sales_data对象中
- 一个print函数，将Sales_data对象的值输出到ostream

> 开发
>
> 优秀的类设计者除了充分了解并实现用户的需求，还应该密切关注哪些有可能使用该类的程序员的需求。
>
> 一个设计良好的类，既要有易于使用的接口，也必须具备高效的实现过程。

> 注意
>
> 定义在类内部的函数是隐式的inline函数

定义成员函数

所有类成员必须在类内部声明，但是可以自由选择在类内或类外定义。

this使用

当我们调用成员函数时，实际上是**替**某个对象调用它。例如：

```cpp
/* 某个成员函数 */
std::string isbn() const { return bookNo; }
```

当我们调用isbn成员函数时，返回的bookNo数据成员，那么其隐式的返回的应该是total.bookNo（假设该函数的对象为total）。

成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如：

```cpp
/* 如果调用 */
total.isbn();
/* 编译器将会把total的地址传递给isbn的隐式形参this,等价于下面这个伪代码 */
Sales_data::isbn(&total);
```

> 注意
>
> 在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符，因为this所指的正是这个对象。任何对类成员的直接访问都被看作this的隐式引用。
>
> 因为this的目的总是指向“这个”对象，所以this是一个常量指针。


引入const成员函数

在成员函数中，存在这种写法：

```cpp
std::string isbn() const {return bookNo};
```

其中，const关键字作用于修改隐式this指针的类型。

在默认情况下，this的类型是指向类类型非常量版本的常量指针。对使用这种const方式的函数成为常量成员函数（const member function）。

我们可以将上述写法想象成：

```cpp
std::string Sales_data::isbn(const Sales_data * const this){
    return this->bookNo;
}
```


类作用域和成员函数

**类本身就是一个作用域，类的成员函数的定义嵌套在类的作用域之内**。

如果在类的外部定义成员函数，其定义必须与它的声明匹配，同时外部定义的成员的名字必须包含它所属的类名。


定义一个返回this对象的函数


### 定义类相关的非成员函数

类作者常常需要定义一些辅助函数，例如：add、read、print等等。这些辅助函数从概念上讲属于是类的接口的一部分，但是实际上其并不属于类。虽然实际上不属于类，但是概念上属于，所以一般将这些非成员函数写在同一个头文件中。


