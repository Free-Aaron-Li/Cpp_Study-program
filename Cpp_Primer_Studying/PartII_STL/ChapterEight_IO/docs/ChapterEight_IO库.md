# 第八章 IO库

## 前言

C++语言并不会直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备中读取数据、向设备写入数据IO操作。设备可以是文件、控制台窗口等，还有一些类型允许内存IO。

IO库定义了读写内置类型值的操作。

---

## 8.1 IO类

在之前我们使用的IO类型和对象都是操作char数据且这些对象都是关联到用户的控制台窗口。但在实际开发中还不够，所以在C++的IO操作中还包括一下类型供开发者使用。

在头文件iostream定义了读写流的基本类型、fstream定义了读写命名文件的类型、sstream定义了读写内存string对象的类型。

|   头文件    |                                                             类型                                                             |
|:--------:|:--------------------------------------------------------------------------------------------------------------------------:|
| iostream |                        istream，wistream 从流读取数据<br/>ostream，wostream向流写入数据<br/>iostream，wiostream读写流                        |
| fstream  |                      ifstream，wifstream从文件读取数据<br/>ofstream，wofstream向文件写入数据<br/>fstream，wfstream读写文件                      |
| sstream  | istringstream，wistringstream从stream读取数据<br/>ostringstream，wostringstream向string写入数据<br/>stringstream，wstringstream读写string |

为了支持宽字符的语言，标准库定义了一组类型与对象来操作wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。

从概念上讲，IO操作并不会因为设备类型和字符大小而受到影响。例如，我希望通过某个文件读取宽字符数据，其与在终端窗口读取普通字符数据其操作都是一致的，都是通过输入运算符>>
。那么这样就存在一个好处，我们可以忽略不同类型的流之间的差异（但并不是不存在差异），使得开发效率得到提高。

这种忽略流差异的技术通过**继承机制**（inheritance）实现，利用模板，通过使用具有继承关系的类使得我们忽略工作细节。

### IO对象无拷贝或赋值

如标题，IO对象不存在拷贝或者赋值初始化的操作：

```cpp
ofstream of_1,of_2;
of_1=of_2; /* 错误：无法对流对象进行赋值 */
ofstream print(ofstream); /* 错误：无法初始化ofstream参数 */
of_2=print(of_2); /* 错误：无法拷贝流对象 */
```

由此引申出，无法将返回类型或者形参设置为流类型，同时由于*读写一个IO对象会改变其状态*，所以常常使用引用方式传递和返回流且此引用不能为const。

### 状态条件

IO操作并不是万无一失的，其潜在可能发生的错误，有一些错误能够较为容易修复，但是有一些错误其可能在系统层面，其修复的范围远远超过应用层面，这时就需要一些IO操作上的函数或者标志来帮助程序确定IO操作状态，其称为访问和操作流的**条件状态**（condition state)。

|        状态名        |                                 解释                                 |
|:-----------------:|:------------------------------------------------------------------:|
| **strm**::iostate |                  iostate是一种机器相关的类型，提供了表达条件状态的完整功能                  |
| **strm**::badbit  |                              指出流已经崩溃                               |
| **strm**::failbit |                             指出一个IO操作失败                             |
| **strm**::eofbit  |                            指出流已经到达文件结束                             |
| **strm**::goodbit |                          指出流处于错误状态，此值保证为零                          |
|      s.eof()      |                        若s流的eofbit置位，则返回true                        |
|     s.fail()      |                   若s流的failbit或者badbit置位，则返回true                    |
|      s.bad()      |                        若s流的badbit置位，则返回true                        |
|     s.good()      |                         若s流处于有效状态，则返回true                          |
|     s.clear()     |                  将s流中所有条件状态位复位，将流的状态设置为有效，返回void                   |
|  s.clear(flags)   | 根据给定的flags标志位，将s流中对应的条件状态位复位。<br/>flags的类型为**strm**.iostate，返回void |
| s.setstate(flags) | 根据给定的flags标志位，将s流中对应的条件状态位置位。<br/>flags的类型为**strm**.iostate，返回void |
|    s.rdstate()    |             返回s流的当前条件状态。<br/>返回值的类型为：**strm**::iostate             |

> **strm**是一种IO类型，s为流

当一个流发生错误，那么后续的IO操作都会失败，为了程序的健壮性，通常需要使用流之前判断其是否处于良好状态。最简单的方式：

```cpp
 while(cin>>word)
    /* ok,next */
```
当流出现问题，我们肯定希望查询到错误原因，这个时候就需要依赖条件状态，IO库定义了一个与机器相关的iostate类型，其提供表达流状态的完整功能，作为一个位集合使用。通过位运算符进行一次性检测或者设置多个标志位。

具体来讲：

- badbit，系统级错误，例如：不可恢复的读写错误。当badbit被置位，流就无法再使用
- failbit，发生可恢复错误，例如：期望读取数值结果读取字符，当错误被修复，流还可以使用。
- 当读取文件结束，eofbit和failbit都会被置位，goodbit值为0,表示流未发生错误。
- 如果badbit、failbit和eofbit任意一个被置位，则检测状态的条件会失败。

在上述描写到，IO库定义的一系列查询标志位的函数，当错误位被置位时其对应的函数就会返回true，注意一点，无论是badbit还是eofbit还是其本身failbit被置位，都会同时触发fail()函数，所以在上述判断流状态的条件代码实际等价于`!fail()`。

#### 管理条件状态

在上述列表上介绍了四种管理条件状态的函数，我们可以使用`clear()`清除所有错误标志位，也可以使用`clear(flags)`清除指定的错误标志位，例如：

```cpp
/* 假设cin出现所有的错位状态位 */
/* 希望复位单一状态位 */
cin.clear(cin.rdstate()&~cin.failbit&~cin.badbit);
```
我们可以通过读取当前状态，例如上述代码，我们就可以复位failbit和badbit，但是eofbit保持不变。

























