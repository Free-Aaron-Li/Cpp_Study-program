# 第八章 IO库

## 前言

C++语言并不会直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备中读取数据、向设备写入数据IO操作。设备可以是文件、控制台窗口等，还有一些类型允许内存IO。

IO库定义了读写内置类型值的操作。

---

## 8.1 IO类

在之前我们使用的IO类型和对象都是操作char数据且这些对象都是关联到用户的控制台窗口。但在实际开发中还不够，所以在C++的IO操作中还包括一下类型供开发者使用。

在头文件iostream定义了读写流的基本类型、fstream定义了读写命名文件的类型、sstream定义了读写内存string对象的类型。

|   头文件    |                                                             类型                                                             |
|:--------:|:--------------------------------------------------------------------------------------------------------------------------:|
| iostream |                        istream，wistream 从流读取数据<br/>ostream，wostream向流写入数据<br/>iostream，wiostream读写流                        |
| fstream  |                      ifstream，wifstream从文件读取数据<br/>ofstream，wofstream向文件写入数据<br/>fstream，wfstream读写文件                      |
| sstream  | istringstream，wistringstream从stream读取数据<br/>ostringstream，wostringstream向string写入数据<br/>stringstream，wstringstream读写string |

为了支持宽字符的语言，标准库定义了一组类型与对象来操作wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。

从概念上讲，IO操作并不会因为设备类型和字符大小而受到影响。例如，我希望通过某个文件读取宽字符数据，其与在终端窗口读取普通字符数据其操作都是一致的，都是通过输入运算符>>
。那么这样就存在一个好处，我们可以忽略不同类型的流之间的差异（但并不是不存在差异），使得开发效率得到提高。

这种忽略流差异的技术通过**继承机制**（inheritance）实现，利用模板，通过使用具有继承关系的类使得我们忽略工作细节。

### IO对象无拷贝或赋值

如标题，IO对象不存在拷贝或者赋值初始化的操作：

```cpp
ofstream of_1,of_2;
of_1=of_2; /* 错误：无法对流对象进行赋值 */
ofstream print(ofstream); /* 错误：无法初始化ofstream参数 */
of_2=print(of_2); /* 错误：无法拷贝流对象 */
```

由此引申出，无法将返回类型或者形参设置为流类型，同时由于*读写一个IO对象会改变其状态*，所以常常使用引用方式传递和返回流且此引用不能为const。

### 状态条件

IO操作并不是万无一失的，其潜在可能发生的错误，有一些错误能够较为容易修复，但是有一些错误其可能在系统层面，其修复的范围远远超过应用层面，这时就需要一些IO操作上的函数或者标志来帮助程序确定IO操作状态，其称为访问和操作流的
**条件状态**（condition state)。

|        状态名        |                                 解释                                 |
|:-----------------:|:------------------------------------------------------------------:|
| **strm**::iostate |                  iostate是一种机器相关的类型，提供了表达条件状态的完整功能                  |
| **strm**::badbit  |                              指出流已经崩溃                               |
| **strm**::failbit |                             指出一个IO操作失败                             |
| **strm**::eofbit  |                            指出流已经到达文件结束                             |
| **strm**::goodbit |                          指出流处于错误状态，此值保证为零                          |
|      s.eof()      |                        若s流的eofbit置位，则返回true                        |
|     s.fail()      |                   若s流的failbit或者badbit置位，则返回true                    |
|      s.bad()      |                        若s流的badbit置位，则返回true                        |
|     s.good()      |                         若s流处于有效状态，则返回true                          |
|     s.clear()     |                  将s流中所有条件状态位复位，将流的状态设置为有效，返回void                   |
|  s.clear(flags)   | 根据给定的flags标志位，将s流中对应的条件状态位复位。<br/>flags的类型为**strm**.iostate，返回void |
| s.setstate(flags) | 根据给定的flags标志位，将s流中对应的条件状态位置位。<br/>flags的类型为**strm**.iostate，返回void |
|    s.rdstate()    |             返回s流的当前条件状态。<br/>返回值的类型为：**strm**::iostate             |

> **strm**是一种IO类型，s为流

当一个流发生错误，那么后续的IO操作都会失败，为了程序的健壮性，通常需要使用流之前判断其是否处于良好状态。最简单的方式：

```cpp
 while(cin>>word)
    /* ok,next */
```

当流出现问题，我们肯定希望查询到错误原因，这个时候就需要依赖条件状态，IO库定义了一个与机器相关的iostate类型，其提供表达流状态的完整功能，作为一个位集合使用。通过位运算符进行一次性检测或者设置多个标志位。

具体来讲：

- badbit，系统级错误，例如：不可恢复的读写错误。当badbit被置位，流就无法再使用
- failbit，发生可恢复错误，例如：期望读取数值结果读取字符，当错误被修复，流还可以使用。
- 当读取文件结束，eofbit和failbit都会被置位，goodbit值为0,表示流未发生错误。
- 如果badbit、failbit和eofbit任意一个被置位，则检测状态的条件会失败。

在上述描写到，IO库定义的一系列查询标志位的函数，当错误位被置位时其对应的函数就会返回true，注意一点，无论是badbit还是eofbit还是其本身failbit被置位，都会同时触发fail()
函数，所以在上述判断流状态的条件代码实际等价于`!fail()`。

#### 管理条件状态

在上述列表上介绍了四种管理条件状态的函数，我们可以使用`clear()`清除所有错误标志位，也可以使用`clear(flags)`清除指定的错误标志位，例如：

```cpp
/* 假设cin出现所有的错位状态位 */
/* 希望复位单一状态位 */
cin.clear(cin.rdstate()&~cin.failbit&~cin.badbit);
```

我们可以通过读取当前状态，例如上述代码，我们就可以复位failbit和badbit，但是eofbit保持不变。

### 管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据。

缓冲机制的存在可以带来很大的性能提升，操作系统可以将（多个）程序的（多个）输出操作组合成为单一的系统级别写操作。

例如：

```cpp
cout<<"hello";
cout<<"world";
cout<<endl;
cout<<"!";
```

在前两行表达式就是将输出操作组合在一起，都存放在缓冲区。第三行则进行缓冲区的刷新，那么第四行表达式中数据就和前两行数据不存放在一起（前两行数据已经被刷新掉了）。

导致缓冲刷新的原因有很多，例如：

- 程序正常结束，作为main函数的return操作的一部分，缓冲刷新将会被执行
- 缓冲区已满，后入的数据只有在刷新缓冲区后才能继续写入缓冲区
- 使用操作符endl显式刷新缓冲区
- 在每个输出操作之后，使用操作符unitbuf设置流的内部状态，借此清空缓冲区
    - 默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的
- 一个输出流可能被关联到另一个流
    - 当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或者写cerr都会导致cout的缓冲区被刷新。

#### 刷新输出缓冲区

在此之前，我们使用操作符endl来进行换行和刷新缓冲区（当时我们可能还没注意到endl具有刷新缓冲区的功能）。类似的，IO库中还存在flush和ends两种操作符也可以执行刷新操作。

flush刷新缓冲区，但是不输出任何额外的字符（类似endl但不换行）；ends向缓冲区插入一个空字符，然后刷新缓冲区。

如果想要在每次输出操作后都执行刷新缓冲区的操作，那么我们可以使用unitbuf操作符。它告诉流在接下来的每次写操作之后都会进行一次flush操作。nounitbuf操作符则是重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。

```cpp
cout<<unitbuf; /* 下面所有的输出操作均会立即刷新缓冲区 */
/* .... */
cout<<nounitbuf; /* 回到正常的缓冲方式 */
```

> 注意
> 
> 如果程序崩溃，输出缓冲区是不会被刷新的
> 
> 如果程序异常终止，其缓冲区不会被刷新。其所输出的数据很可能停留在输出缓冲区中等待打印
> 
> 注意这个细节，如果我们调试一个已经崩溃的程序，需要检查认为已经输出的数据确实已经被刷新了，否则追踪一个没有价值的代码是毫无意义的。

#### 关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。

在IO库中，cin默认已经和cout关联在一起，也就是说当执行cin语句时，在此之前的cout的缓冲区
将会被刷新。

> 开发
> 
> 交互式系统通常应该关联输入流和输出流。这意味着所有的输出，包括用户提示信息，都会在读操作之前被打印出来。

我们可以通过tie函数关联流。

```cpp
cin.tie(&cout); /* 将cin和cout关联 */
cin.tie(nullptr); /* cin不再和其他流关联 */
cin.tie(&cerr); /* cin与cerr关联 */
```

