# 第9章 顺序容器

## 前言

本章是对第三章——字符串、向量和数组的扩展延伸，在第三章我们对标准库的顺序容器有一定了解，那么学习完本章我们对顺序容器的知识将会更加完整。

标准库定义了几种关联容器，关联容器中元素的位置由元素相关联的关键字值决定。我们将在本章对关联容器做一定了解，在第十一章将会介绍关联容器特有的操作。

在第三章我们就发现，顺序容器在操作上似乎有共通性，原因是在容器类共享公共的接口，不同容器按照不同方式对其进行扩展。当然每种容器都提供不同的性能和功能的权衡。

容器可以看作一些特定类型对象的集合。**顺序容器**（sequential container)则是为用户（一般是程序员）提供控制元素存储和访问顺序的能力，根据元素加入容器的位置相对应。与之相对的则是关联容器，其依赖于元素的值，根据关键字的值来存储元素。

此外，标准库还提供三种容器适配器，分别为容器操作定义不同的接口，来借此与容器类型进行适配。

---

## 9.1 顺序容器概述

在前言简述了顺序容器的概念，标准库中存在以下顺序容器：

|    顺序容器类型    |                      解释                      |
|:------------:|:--------------------------------------------:|
|    vector    |   可变大小数组。支持快速随机访问。在**尾部之外**的位置插入或删除元素可能很慢    |
|    array     |          固定大小数组。支持快速随机访问。不能添加或删除元素           |
|    string    | 与vector相似的容器，但专门用于保存字符。随机访问快。在**尾部**插入/删除速度快 |
|    deque     |       双端队列。支持快速随机访问。在**头尾位置**插入/删除速度很快       |
|     list     |   双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快    |
| forward_list |     单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快     |

> 从上述的解释中，我们不难发现顺序容器有着不同的性能折中。
> 
> 例如：
>> 插入/删除元素较慢（以向容器添加或删除元素为代价）
>>
>> 无法进行快速随机访问（以非顺序访问容器元素为代价）

> 补充
> 
> forward_list和array是C++11中新增加的类型。
> 
> forward_list在设计之初，其目的就是为了获得与最好的手写单向链表数据结构一致的性能，所以该类型并没有size操作，毕竟保存或计算其大小也会比手写链表多出额外开销:)。
> 
> array类型与内置类型概念上一致，但是array更为安全、容易使用。当然，array对象大小是固定的，所以不支持添加和删除元素以及改变容器大小的操作。

虽然我们不愿承认大多数开发者设计的数据结构比标准库中容器运行速度慢，但事实便是如此:)。在C++下的标准库中容器的性能几乎与精心设计优化的同类数据结构一样好（通常更好😉）。

#### 确定使用哪种顺序容器

> 如无特殊要求，vector无疑是最好的选择。

顺序容器并不能依靠随性选择，而应该结合实际需求。当鱼与熊掌不可兼得时，我们必要时还需要通过测试性能获得最佳答案。

那么以下是一些选择顺序容器的基本原则：

- 在没有特殊/很好的理由下，vector是不二之选
- 如果程序中存在很多容量较小元素，同时空间的额外开销很重要。请不要选择list/forward_list
- 如果程序要求随机访问元素，则应该选择vector/deque
- 如果程序要求在容器中间插入/删除元素，则应该选择list/forward_list
- 如果程序需要头尾位置插入/删除元素，同时不会在中间位置插入/删除元素，则应该选择deque
- 如果程序只有在读取输入时，在输入阶段需要在容器中间位置插入元素，随后需要随机访问元素，那么
  - 首先，确定是否需要在容器中间位置插入元素。当处理数据时，通常很容易向vector追加数据，再通过调用sort函数重排容器中的元素，相对于直接在容器中间位置插入元素性能更优
  - 如果必须这样做，那么我们应该考虑在输入阶段使用list，在读取阶段将list中内容拷贝到vector中。

> 开发
> 
> 在不确定使用何种容器的情况下，使用公共操作对容器进行操作绝对是最好的选择！例如，无法确定是使用vector还是list，我们应该避免使用下标，而应该使用迭代器操作。

## 9.2 容器库概览

容器类型上的操作形成了一种**层次**：

- 某些操作是所有容器类型都提供的
- 另外一些操作仅针对顺序容器、关联容器或无序容器
- 还有一些操作只适用于一小部分容器

一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。容器均定义为模板类，所以我们必须提供额外信息来生成特定的容器类型。同时对大多数容器而言，我们还需要提供元素类型信息。

所有容器类型都提供的操作：

|            容器操作            |                解释                 |
|:--------------------------:|:---------------------------------:|
|            类型别名            |                                   |
|          iterator          |            此容器类型的迭代器类型            |
|       const_iterator       |       可以读取元素，但不能修改元素的迭代器类型        |
|         size_type          |    无符号整数类型，足够保存此种容器类型最大可能容器的大小    |
|      difference_type       |      带符号整数类型，足够保存两个迭代器之间的距离       |
|         value_type         |               元素类型                |
|         reference          |     元素的左值类型：与value_type&含有相同      |
|      const_reference       |           元素的const左值类型            |
|            构造函数            |                                   |
|            C c;            |       默认构造函数，构造空容器(array除外）       |
|         C c1(c2);          |             构造c2的拷贝c1             |
|         C c(b,e);          | 构造c，将迭代器b和e指定范围内的元素拷贝到c（array不支持） |
|       C c{a,b,c...};       |              列表初始化c               |
|          赋值与swap           |                                   |
|           c1=c2            |          将c1中的元素替换为c2中元素          |
|       c1={a,b,c...}        |    将c1中的元素替换为列表中元素（ array不支持）     |
|         a.swap(b)          |             交换a和b的元素              |
|         swap(a,b)          |           与a.swap(b)等价            |
|             大小             |                                   |
|          c.size()          |      c中元素数目（forward_list不支持）      |
|        c.max_size()        |            c可保存的最大元素数目            |
|         c.empty()          |            判断c容器元素是否为空            |
|     添加/删除元素（array不支持）      |                                   |                
|                            |        注：在不同容器中，这些操作的接口都不同        |
|       c.insert(args)       |           将args中元素拷贝进c            |
|      c.emplace(inits)      |         使用inits构造c中的一个元素          |
|       c.erase(args)        |            删除args指定的元素            |
|         c.clear()          |          删除c中所有元素，返回void          |
|           ==,!=            |            相等（不相等）运算符             |
|         <,<=,>,>=          |         关系运算符(无序关联容器不支持）          |               
|           获取迭代器            |                                   |
|     c.begin(),c.end()      |       返回指向c的首元素和尾元素之后位置的迭代器       |
|    c.cbegin(),c.cend()     |         返回const_iterator          |
| 反向容器的额外成员（forward_list不支持） |                                   |
|      reverse_iterator      |           按照逆序寻址元素的迭代器            |
|   const_reverse_iterator   |           不能修改元素的逆序迭代器            |
|    c.rbegin(),c.rend()     |       返回指向c的尾元素和首元素之前位置的迭代器       |
|   c.crbegin(),c.crend()    |     返回const_reverse_iterator      |

### 迭代器

与容器类似，迭代器同样存在公共接口。

|      运算符      |                        解释                        |
|:-------------:|:------------------------------------------------:|  
|    \*iter     |               返回迭代器iter所指元素的引用，解引用               |  
|  iter ->mem   |      解引用iter并获取该元素的名为mem的成员，等价于(\*item).mem      |  
|    ++iter     |                 令iter指示容器的下一个元素                  |  
|    --iter     |                 令iter指示容器中的上一个元素                 |  
| iter1\==iter2 | 判断两个迭代器是否相等，如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等 |  

> forward_list迭代器不支持递减运算符

**迭代器范围**（iterator range）由一对迭代器表示。两个迭代器分别指向**同一个**容器中的元素或者**尾元素之后**元素位置（one past the last element）[one piece :)]。从数学的角度我们可以认为该范围是**左闭合区间**（left-inclusive interval）。

那么，我们为什么要采用这种方式的迭代器范围呢？

好处有三：

- 如果begin和end相等，说明范围为空
- 如果二者不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素
- 通过对begin的递增，可以使得begin=end

```cpp
/* value为可行值 */
while(begin!=end){
  *begin=value;
  ++begin;
}
```
从上例可以看出：在此循环之内都可以安全的解引用begin，begin必定指向一个元素，同时我们也能确定该循环最终必定会结束。

### 容器类型成员

在前面的章节中我们遇见过size_type、iterator和const_iterator三种类型。后两种类型都是迭代器类型，加上前面介绍的反向迭代器的reverse_iterator和const_reverse_iterator两种类型，我们现在总共认识五种容器类型。

上述类型均为类型别名。类型别名的作用是在不了解容器中元素类型的情况下使用它，比如，需要元素类型，可以使用value_type，如果需要元素类型的引用使用reference或者const_reference。这在泛型编程中很有作用。

例如：

```cpp
std::vector<int>::iterator it;
std::vector<int>::difference_type df;
```

### begin和end成员

begin和end存在多个版本，其中：

- 带r版本返回反向迭代器
- 带c版本返回const迭代器

当对const对象调用这些成员时，获得的是const版本迭代器。

比较常用的是将auto和begin与end结合，获得的迭代器依赖于容器类型（C++11支持），这样我们可以不用显式声明迭代器类型。

> 开发
> 
> 在不需要进行访问操作时，应该使用cbegin和cend。

### 容器定义和初始化

每个容器类型都定义了一个默认构造函数。容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数（除了array之外）。

|             容器定义与初始化             |                  解释                   |
|:--------------------------------:|:-------------------------------------:|
|               C c                |                默认构造函数                 |
|       C c1(c2)<br/>C c1=c2       | c1初始化为c2的拷贝，c1和c2必须相同类型、相同容器类型、相同元素类型 |
| C c{a,b,c...}<br/>C c={a,b,c...} | c初始化为初始化列表中元素的拷贝。列表中元素类型必须与C的元素类型相容。  |
|             C c(b,e)             |      c初始化为迭代器b和e指定范围中的元素的**拷贝**。      |
|              C c(n)              | c中包含n个元素，这些元素均进行值初始化，且该构造函数为explicit  |
|            C seq(n,t)            |            c中包含n个初始值为t的元素             |

> 注意
> 
> array容器是特殊的。
> 
> 容器的默认构造函数中，如果容器为array则容器中元素按照默认方式初始化，否则该容器为空。
> 
> 在进行两容器对象拷贝初始化时，array容器除了上述条件还需要保证二者必须具有**相同大小**。
> 同样，对容器对象进行列表初始化，列表中元素数目必须小于等于array的大小，对遗漏的元素进行值初始化。
> 
> array容器无法通过迭代器指定范围中的元素进行拷贝，也无法仅指明元素大小的方式初始化容器。

那么，通过上面的列表，我们可以总结出：

- 将一个容器初始化为另一个容器的拷贝
  - 直接进行拷贝`C c1(c2)`，或者通过迭代器指定元素范围进行拷贝`C c1(it_begin,it_end)`。当然以上array容器均不可以使用😅
  - 需要注意的是：
    - **当直接通过一个容器的拷贝对另一个容器进行初始化时，两个容器的容器类型和元素类型必须相同**，但是如果选择通过传递迭代器参数的方式，则不需要容器类型相同，甚至不需要元素类型相同，只要拷贝的元素能够转换到被初始化的元素类型即可。
      ```cpp
      std::vector<std::string> v1{"hello","world","!"};
      std::vector<const char*> word{"h","e","l","l","o","!"};
      std::forward_list<std::string> v2{v1.cbegin(),v1.cend()};
      /* const char*转换为string */
      std::forward_list<std::string> v3{word.cbegin(),word.cend()};
      ```
    - 既然可以使用迭代器参数来表示一个容器的元素范围，那么也就可以用来表示一个容器的子序列
      ```cpp
      /* it_1,it_2分别表示某个正确容器的某个迭代器，其指向正确元素且it_1<it_2 */
      std::vector<int> total(it_1,it_2);      
      ```
- 列表初始化
  - 当我们采用列表初始化的方式，实际上显式指定容器中每个元素的值并隐含指定了容器的大小。当然array除外🙃
- 与顺序容器相关的构造函数
  - 除了与关联容器相同的构造函数外，顺序容器（当然不包括array🫠）还提供另外一种构造函数。其会接受一个容器大小和一个（可选）元素初始值。如果不提供元素初始值，则默认会创建一个值初始化器。
    ```cpp
    std::vector<int> v_1(10,1);
    std::vector<int> v_2(10);
    ```
  - 注意：
    - 如果元素类型是内置类型或者具有默认构造函数的类类型，则允许只为构造函数提供一个容器大小参数，但是如果元素类型并没有默认构造函数，那么除了提供容器大小参数外，还必须显式指定元素初始值。
    - 只有顺序容器的构造函数才接受大小参数，关联函数不支持
- array具有固定大小
  - 与内置数组一致，标准库array的大小也是类型的一部分。所以在定义array时必须指定元素类型和容器大小
    ```cpp
      array<int,10>::iterator it; /* ok */
      array<int>::size_type i; /* error */    
    ```
    因此，在array并不支持普通的容器构造函数，这些构造函数都会确定容器的大小（无论是显式还是隐式）。同时在大多数情况下允许向一个array构造函数传递大小参数是错误的（也是多余的）。
  - 这种固定大小特性同样影响其构造函数的行为。
    - 默认构造的array容器应该是非空的（这点于普通容器不同），其内元素被默认初始化。
    - 在进行列表初始化时，初始值数目需要小于等于array大小。
    - 列表初始化随顺序依次初始化容器内元素，如果存在遗漏则进行值初始化。所以**当元素类型是类类型时，该类必须存在默认构造函数，否则值初始化不成功**。
  - 对array进行拷贝和对象赋值
    - 在内置数组类型下是不允许进行拷贝或者对象赋值操作的，但是array不存在此限制。
    - 要求与其他容器一致，初始值的类型必须与要创建的容器类型相同、元素类型一致。但是还要求容器大小一致，毕竟容器大小也是array类型的一部分。

### 赋值和swap

在对容器的操作中，赋值运算符就是将左边容器中的全部元素替换成右边容器中元素的拷贝。

|           容器赋值运算            |                       解释                        |
|:---------------------------:|:-----------------------------------------------:|
|            c1=c2            |         将c1中的元素替换成c2中元素的拷贝。c1和c2类型必须相同          |
|        c={a,b,c...}         |         将c1中元素替换为初始化列表中元素的拷贝（array不支持）          |
| swap(c1,c2)<br/>c1.swap(c2) | 交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多 |
|        c.assign(a,b)        |     将c中元素替换为迭代器a和b所表示范围内的元素。迭代器a和b不能指向c中元素      |
|        c.assign(il)         |               将c中元素替换为初始化列表il中的元素               |
|        c.assign(n,t)        |                将c中元素替换为n个值为t的元素                 |
> 注意
> 
> assign操作不支持关联容器和array😉。
> 
> 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，但是swap操作例外（当然array和string容器除外）。

总结表格中的特殊点和注意点：
- 赋值运算左值和右值
  - 在`c1=c2`的格式下，赋值符号左右两边值的大小都将于右值大小一致
  - 在`c1={1,2,3}`的格式下，c1的大小将会与初始值列表的大小一致
- array容器
  - 和内置数组不一样的，array容器允许赋值，但是赋值符号左右两边的运算对象类型必须一致
  - 由于有运算对象的大小可能和左边对象不一致，所以array类型不支持assign，也不允许使用花括号包围的值列表进行赋值
  - 使用assign（仅顺序容器支持）
    - 赋值运算要求左右两边运算对象必须具有相同类型，那么顺序容器还提供另外一种方式，通过assign成员允许我们及那个不同但是相容的类型赋值。类似于seq成员之于容器初始化
      ```cpp
        list<string> name;
        vector<const char*> oldstyle;
        name=oldstyle; /* error */
        name.assign(oldstyle.cbegin(),oldstyle.cend()); /* ok */
      ```
    - 由于其旧元素被替换，所以**传递给assign的迭代器不能指向调用assign的容器**
    - 除了上述的方式外，assign还接受一个整数值和一个元素值
      ```cpp
        list<string> name(1); /* 1个元素，为空string */    
        list<string> name.assign(10,"hi"); /* 10个元素，每个都是hi */
      ```
- 使用swap
  - swap操作交换两个相同类型容器的内容。
    ```cpp
      vector<string> v1(10);
      vector<string> v2(20);
      swap(v1,v2); /* 交换元素，v1将会有20个元素，v2将会有10个元素 */    
    ```
  - swap本质上交换的是两个容器内部数据结构，元素本身并未交换。所以除了array之外，swap不会对任何元素进行拷贝、删除或者插入操作，因此可以保证在常数时间内完成。那么就表示指向容器的迭代器、引用和指针在swap操作之后都不会失效，但是**在swap之后，已经属于不同的容器了**。
  - 当然，array又是一个例外，swap操作对于两个array是真正交换对应元素。所以，交换两个array所需时间与array中元素数目成正比。

### 容器大小操作
  
每个容器类型都有三个与之大小相关的操作（存在一个例外，forward_list不支持size）。

- 成员函数size返回容器中元素的数目
- 成员函数empty返回当size等于0时布尔值为true，反之为false
- max_size返回一个大于等于该类型容器所能容纳的最大元素数值

### 关系运算符

每个容器类型都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（\>、\>=、\<、\<=）。当然关系运算符左右两方对象必须是相同类型容器，保存相同类型元素。

在前面我们介绍迭代器时就讲述过这些关系运算符的基本运行规则，下面详细描述一遍：

总体上遵守元素逐对比较，先判元素大小后判容器大小。

- 如果两个容器具有相同大小且所有元素都两两相等，则这两个容器相等；否则两个容器不等
- 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
- 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等元素的比较结果

例如：

```markdown
a1: 1,3,5,7,9,11
a2：1,3,6
a3：1,3,5,7
a4：1,3,5,7,9,11
a5：1,3,7

那么：
a1>a2，虽然a1[2]小于a2[2]，但是a1容量更大
a1>a3，a3相当于a1的子序列
a1=a4，二者逐个元素相等
a2<a5，二者在第三个元素比较上，a5第三个元素更大且二者容器大小一致
```

从上述我们不难看出**容器的关系运算符实际上使用元素的关系运算符完成比较**。容器的比较实际上是元素的比较。

借此我们也会发现，仅元素类型支持关系运算符时，容器之间才能进行比较。





   
  