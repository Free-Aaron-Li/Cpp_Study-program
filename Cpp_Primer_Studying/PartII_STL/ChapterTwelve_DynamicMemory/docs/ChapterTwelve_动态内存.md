# 第十二章 动态内存

## 前言

在此之前，我们使用的程序中对象都有着严格定义的生存期：

- 全局对象，在程序启动时分配，在程序结束是销毁。
- 局部自动对象，当进入定义所在程序时创建，在离开块时销毁。
- 局部static对象，在第一次使用前分配，在程序结束时销毁。

显然这存在限制，为此C++支持动态<b>分配对象</b>。动态分配对象的生存期与它们在哪里创建无关，只有当显式地被释放时，这些对象才会被销毁。

<b>动态对象的正确释放被证明时编程中极其容器出错的地方</b>。那么为了更安全释放，标准库定义了两个<b>智能指针</b>来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。

> 静态内存：局部static对象、类static数据成员以及定义在任何函数之外的变量
>
> 栈内存：定义在函数内的非static对象
>
> 分配在静态或栈内存的对象由编译器自动创建和销毁。除了静态内存和栈内存，每个程序还拥有一个内存池。称为<b>自由空间</b>或<b>堆</b>，程序用堆来存储<b>动态分配</b>（dynamically allocate）的对象——即那些在程序运行时分配的对象。

## 动态内存和智能指针

在C++中，动态内存的管理通过一对运算符完成：

- <b>new</b>，在动态内存中为对象分配空间并返回一个指向对象的指针，可以选择对对象初始化
- <b>delete</b>，接受一个动态对象的指针，销毁指针指向对象，并释放与之关联的内存

但是动态内存的使用容易出问题，难以确保在正确时间释放内存，那么就可能出现“内存泄露”、“引用非法指针”等。对此，标准库引入两种智能指针（smart pointer）：

- <b>shared_ptr</b>，允许多个指针指向同一个对象
- <b>unique_ptr</b>，独占所指向的对象

> 智能指针的行为类似常规指针，区别在于智能指针负责自动释放所指向的对象。上述的两种指针区别在于管理底层指针的方式不同。
>
> 同时，标准库还定义了一个<b>weak_ptr</b>的伴随类，其是一个弱引用，指向shared_ptr所管理的对象。三者均定义在`memory`头文件中。

### shared_ptr类

智能指针为模板，在创建时需要提供额外的信息表明指针可以指向的类型。

```cpp
shard_ptr<string> p_1;
shard_ptr<list<int>> p_2;
```

|      shared_ptr和unique_ptr都支持的操作      |                      解释                      |
|:-------------------------------------:|:--------------------------------------------:|
| shared_ptr<T> sp<br/>unique_ptr<T> up |              空智能指针，可以指向类型为T的对象               |
|                   p                   |          将p用作一个条件判断，若p指向一个对象，则为true          |
|                  *p                   |                解引用p,获得它指向的对象                 |
|               p->member               |                等价于(*p).member                |
|                p.get()                | 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
|        swap(p,q)<br/>p.swap(q)        |                  交换p和q中的指针                   |

|       shard_ptr独有的操作        |                                     解释                                     |
|:---------------------------:|:--------------------------------------------------------------------------:|
| make_shared<T>(<i>args</i>) |            返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用<i>args</i>初始化此对象             |
|      shared_ptr<T>p(q)      |                p是shared_ptr q的拷贝。此操作会递增q中的计数器。q中的指针必须能转化为T*                |
|             p=q             | p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0,则将其管理的原内存释放 |
|         p.unique()          |                     若p.use_count()为1,返回true,否则返回false                      |
|        p.use_count()        |                        返回与p共享对象的智能指针数量；可能很慢，主要用于调试                         |

#### make_shared函数

<b>最安全的分配和使用动态内存</b>的方法是调用make_shared标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。

```cpp
shared_ptr<int> p_3=make_shared<int>(42); // 指向一个值为42的int
shared_ptr<string> p_4=make_shared<string>(2,'9'); // 指向一个值为“99”的string
shared_ptr<int> p_5=make_shared<int>(); // 指向一个值初始化的int
```

#### shared_ptr的拷贝和赋值

当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：

```cpp
auto p=make_shared<int>(42); // p指向的对象只有p一个引用者
auto q(P); // p和q指向相同对象，此对象有两个引用者
```

我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为<b>引用计数</b>（reference count）。无论何时拷贝一个shared_ptr,计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr,或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减。

当一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象：

```cpp
auto p = make_shared<int>(42); // p指向的int只有一个引用者
p = q; // 给p赋值，令它指向另一个地址
	   // 递增q指向的对象的引用计数
	   // 递减p原来指向的对象的引用计数
	   // p原来指向的对象已经没有引用者，会自动释放
```

> 到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。

#### shared_ptr自动销毁所管理的对象

shared_ptr类会通过<b>析构函数</b>（destructor）完成销毁工作。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数为0,shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。

> 如果将shared_ptr存放在一个容器中，而后不再需要某些元素，而只使用其中的一部分，要记得用erase删除不再需要的那些元素

#### 使用了动态生存期的资源的类

程序使用动态内存出于以下三种原因之一：

- 程序不知道需要多少对象
- 程序不知道所需对象的准确类型
- 程序需要在多个对象间共享数据

 
