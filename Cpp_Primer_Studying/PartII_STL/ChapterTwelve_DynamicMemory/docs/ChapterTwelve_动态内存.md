# 第十二章 动态内存

## 前言

在此之前，我们使用的程序中对象都有着严格定义的生存期：

- 全局对象，在程序启动时分配，在程序结束是销毁。
- 局部自动对象，当进入定义所在程序时创建，在离开块时销毁。
- 局部static对象，在第一次使用前分配，在程序结束时销毁。

显然这存在限制，为此C++支持动态<b>分配对象</b>。动态分配对象的生存期与它们在哪里创建无关，只有当显式地被释放时，这些对象才会被销毁。

<b>动态对象的正确释放被证明时编程中极其容器出错的地方</b>。那么为了更安全释放，标准库定义了两个<b>智能指针</b>来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。

> 静态内存：局部static对象、类static数据成员以及定义在任何函数之外的变量
>
> 栈内存：定义在函数内的非static对象
>
> 分配在静态或栈内存的对象由编译器自动创建和销毁。除了静态内存和栈内存，每个程序还拥有一个内存池。称为<b>自由空间</b>或<b>堆</b>，程序用堆来存储<b>动态分配</b>（dynamically allocate）的对象——即那些在程序运行时分配的对象。

## 动态内存和智能指针

在C++中，动态内存的管理通过一对运算符完成：

- <b>new</b>，在动态内存中为对象分配空间并返回一个指向对象的指针，可以选择对对象初始化
- <b>delete</b>，接受一个动态对象的指针，销毁指针指向对象，并释放与之关联的内存

但是动态内存的使用容易出问题，难以确保在正确时间释放内存，那么就可能出现“内存泄露”、“引用非法指针”等。对此，标准库引入两种智能指针（smart pointer）：

- <b>shared_ptr</b>，允许多个指针指向同一个对象
- <b>unique_ptr</b>，独占所指向的对象

> 智能指针的行为类似常规指针，区别在于智能指针负责自动释放所指向的对象。上述的两种指针区别在于管理底层指针的方式不同。
>
> 同时，标准库还定义了一个<b>weak_ptr</b>的伴随类，其是一个弱引用，指向shared_ptr所管理的对象。三者均定义在`memory`头文件中。

### shared_ptr类

智能指针为模板，在创建时需要提供额外的信息表明指针可以指向的类型。

```cpp
shard_ptr<string> p_1;
shard_ptr<list<int>> p_2;
```

|      shared_ptr和unique_ptr都支持的操作      |                      解释                      |
|:-------------------------------------:|:--------------------------------------------:|
| shared_ptr<T> sp<br/>unique_ptr<T> up |              空智能指针，可以指向类型为T的对象               |
|                   p                   |          将p用作一个条件判断，若p指向一个对象，则为true          |
|                  *p                   |                解引用p,获得它指向的对象                 |
|               p->member               |                等价于(*p).member                |
|                p.get()                | 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
|        swap(p,q)<br/>p.swap(q)        |                  交换p和q中的指针                   |

|       shard_ptr独有的操作        |                                     解释                                     |
|:---------------------------:|:--------------------------------------------------------------------------:|
| make_shared<T>(<i>args</i>) |            返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用<i>args</i>初始化此对象             |
|      shared_ptr<T>p(q)      |                p是shared_ptr q的拷贝。此操作会递增q中的计数器。q中的指针必须能转化为T*                |
|             p=q             | p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0,则将其管理的原内存释放 |
|         p.unique()          |                     若p.use_count()为1,返回true,否则返回false                      |
|        p.use_count()        |                        返回与p共享对象的智能指针数量；可能很慢，主要用于调试                         |

#### make_shared函数

<b>最安全的分配和使用动态内存</b>的方法是调用make_shared标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。

```cpp
shared_ptr<int> p_3=make_shared<int>(42); // 指向一个值为42的int
shared_ptr<string> p_4=make_shared<string>(2,'9'); // 指向一个值为“99”的string
shared_ptr<int> p_5=make_shared<int>(); // 指向一个值初始化的int
```

#### shared_ptr的拷贝和赋值

当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：

```cpp
auto p=make_shared<int>(42); // p指向的对象只有p一个引用者
auto q(P); // p和q指向相同对象，此对象有两个引用者
```

我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为<b>引用计数</b>（reference count）。无论何时拷贝一个shared_ptr,计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr,或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减。

当一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象：

```cpp
auto p = make_shared<int>(42); // p指向的int只有一个引用者
p = q; // 给p赋值，令它指向另一个地址
	   // 递增q指向的对象的引用计数
	   // 递减p原来指向的对象的引用计数
	   // p原来指向的对象已经没有引用者，会自动释放
```

> 到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。

#### shared_ptr自动销毁所管理的对象

shared_ptr类会通过<b>析构函数</b>（destructor）完成销毁工作。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数为0,shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。

> 如果将shared_ptr存放在一个容器中，而后不再需要某些元素，而只使用其中的一部分，要记得用erase删除不再需要的那些元素

#### 使用了动态生存期的资源的类

程序使用动态内存出于以下三种原因之一：

- 程序不知道需要多少对象
- 程序不知道所需对象的准确类型
- 程序需要在多个对象间共享数据

### 直接管理内存

在前面我们知道C++定义了new和delete进行动态内存的分配和释放。相对于智能指针，这两个运算符管理非常容器出错。自己直接管理内存的类与使用智能指针的类不同，它们不能依赖于类对象拷贝、赋值和销毁操作的任何默认定义，因此，使用智能指针的程序更容易编写和调试。

常见的new：

```cpp
int* pi =new int; // pi指向一个动态分配的、未初始化的无名对象
```

默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是为定义的，而类类型对象将用默认构造函数进行初始化。

```cpp
string *p_s=new string;
int *pi=new int;
```

> 默认初始化
>
> 如果定义变量时没有指定初值，则变量被默认初始化（default initialized），此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时<b>定义变量</b>的位置也会对此有影响。
>
> 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0；定义在函数体内部的内置类型变量将<b>不被初始化</b>。一个未被初始化的内置类型变量的值是未定义的。如果试图拷贝或以其他形式访问此类值将引发错误。

对动态分配的对象，我们可以采用直接初始化、传统的构造方式、列表初始化、值初始化的方式进行初始化。

```cpp
int* p_s0=new string; // 默认初始化
int* p_i1=new int(123); // 直接初始化
int* p_s1=new string(10,"1"); // 传统的构造方式
vector<int>* p_v1=new vector<int>{0,1,2,3}; // 列表初始化
string* p_s2=new string(); // 值初始化 
```

> 对于定义了自己的构造函数的类类型（如string）来说，值初始化是没有意义的，但是对内置类型对象来说则有很大的意义：值初始化的的内置类型对象有着良好的值，而默认初始化的对象的值则是未定义的。
>
> 同样，对于类中依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。
>
> 所以，出于与变量初始化相同的原因，<b>对动态分配的对象进行初始化通常是个好主意</b>

这里就有一个“骚操作”：

```cpp
auto p_1 = new auto(obj); // 从obj那里推断想要分配的对象的类型
auto p_2 = new auto{a,b,c}; // 错误，括号中只能有单个初始化器
```

#### 动态分配的const对象

类似其他任何const对象，一个动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化。

```cpp
const int* P_c_i = new const int(1024);
const string* p_c_s = new const string;
```

#### 内存耗尽

如果自由空间（堆空间）资源耗尽，new表达式将会失败，并抛出`bad_alloc`异常。可以改变new方式阻止其抛出异常：

```cpp
int *p_1 = new (nothrow) int; // 如果分配失败，new返回一个空指针
```

对上述代码中形式的new称为<b>定位new</b>（placement new）。定位new表达式允许我们向new传递额外的参数。上述我们向new传递一个由标准库定义的nothrow对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在new头文件中。

#### 释放动态内存

传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的。

虽然一个const对象的值不能被改变，但是其本身是可以被销毁的。

> 由内置指针（而不是智能指针）管理的动态内存在会被显式释放前一直都会存在
>
> 所以，动态内存的管理非常容易出错。
>
> 使用new和delete管理动态内存存在三个常见问题：
>
> 1. 忘记delete内存。忘记释放动态内存会导致“内存泄露”问题，因为这种内存永远不可能被归还给自由空间。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存后，才能检测到这种错误。
> 2. 使用已经释放掉的对象。即“空指针异常”。
> 3. 同一块内存被释放两次。这种情况下自由空间可能被破坏掉。
>
> 相对于查找和修正这些错误来说，制造出错误简单很多。

当delete一个指针后，其指针值无效，但是机器上指针仍然保存已释放动态内存的地址。即<b>空悬指针</b>（dangling pointer）。

未初始化指针的所有缺点空悬指针一个不落。其中“在指针即将离开其作用域前释放掉它所关联的内存”可以作为一种解决方案，如果想要保留指针，需要在delete之后nullptr赋予它，这样清楚地指出指针不指向任何对象。

但这仅仅做出一点小的修复，动态内存的另一个基本问题是存在多个指针指向相同内存的情况，仅解决其中一个指针，其他指针依旧存在问题。

所以，**对于动态内存请务必使用智能指针**！

### shared_ptr和new的结合使用

如果不初始化一个智能指针，那么它就会被初始化为一个空指针。其实，还可以用new返回的指针来初始化智能指针。

```cpp
shared_ptr<double> p1;
shared_ptr<int> p2(new int(42));
```

接受指针参数的智能指针构造函数是explicit的，所以，不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式。相同的，不能将一个智能指针不能隐式转换为内置指针。

```cpp
shared_ptr<int> p1 = new int(1024); //false 内置指针隐式转换为智能指针
```

默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。

|           定义和改变shared_ptr的其他方法            |                                               解释                                                |
|:-----------------------------------------:|:-----------------------------------------------------------------------------------------------:|
|            shared_ptr<T> p(q)             |                             p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型                             |
|            shared_ptr<T> p(u)             |                                 p从unique_ptr u那里接管了对象的所有权：将u置为空                                 |
|           shared_ptr<T> p(q,d)            |                        p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用d来代替delete                        |
|           shared_ptr<T> p(p2,d)           |                           p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete                           |
| p.reset()<br/>p.reset(q)<br/>p.reset(q,d) | 若p是唯一指向其对象的shared_ptr,reset会释放此对象。若传递了可选的参数内置指针q,会令p指向q,否则会将p置为空。若还传递了参数d,就爱能够会调用d而不是delete来释放q |

#### 不要混合使用普通指针和智能指针

shared_ptr可以协调对象的析构，但这仅限于其自身的拷贝（也是shared_ptr）之间。这就是推荐使用make_shared而不是new的原因。这样，可以在分配对象的同时就将shared_ptr与之绑定，从而避免无意中将同一块内存绑定到多个独立创建的shared_ptr上。

```cpp
void process(shared_ptr<int> ptr){ // 值传递，ptr引用计数+1
	// 使用ptr
} // 销毁ptr

shared_ptr<int> p(new int(42)); // 引用计数为1
process(p); // 在process中引用计数为2
int i = *p; // 正确，引用计数为1

int* x(new int(1024)); // 危险：x是一个普通指针
process(x); // 错误，无法隐式转换
process(shared_ptr<int>(x)); // 合法，临时shared_ptr，内存会被释放
int j = *x; //未定义：x是一个空悬指针！
```

当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了。

> 使用一个内置指针访问一个智能指针所负责的对象是危险的，因为我们无法知道对象何时被销毁！

#### 不要使用get初始化另一个智能指针或为智能指针赋值

智能指针类型定义了一个get函数，用于返回一个窒息那个智能指针管理的对象的内置指针。此函数设计的目的是：将指针的<b>访问权限</b>传递给代码。<b>使用get返回的指针的代码不能delete此指针</b>。

<b>将另一个智能指针绑定到get返回的指针上是错误的</b>。

```cpp
shared_ptr<int> p(new int(42)); // 引用计数为1
int* q=p.get(); // 使用q时需要注意，不要让它管理的指针被释放
{
	shared_ptr<int>(q);
} // 当程序块结束，q被销毁，它指向的内存被释放
int x = *p; // 错误，p指向的内存已经被释放
```

p和q指向相同的内存。由于二者相互独立，因此各自引用计数为1.当q所在程序块结束，q被销毁，这会导致q指向的内存被释放。从而导致p变成空悬指针，当意图使用p时，将发生为定义行为。同时，当p被销毁时，这块内存将会被二次delete。

#### 其他shared_ptr操作

可以使用reset来将一个新的指针赋予一个shared_ptr：

```cpp
p = new int(1024); // false
p.reset(new int(1024)); // true
```

与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起使用，来控制多个shared_ptr共享的对象。<b>在改变底层对象之前，需要检查是否是当前对象仅有的用户</b>。如果不是，在改变之前需要进行一份拷贝。

```cpp
if(!p.unique())
	p.reset(new string(*p)); // 分配新的拷贝
*p += newVal; // 是唯一的用户，可以改变对象的值
```







