# 二叉树

## 一、二叉树性质

1. 在二叉树的第i层至多2<sup>i-1</sup>(i>=1)个节点
2. 深度为k的二叉树至多有2<sup>k</sup>-1个节点
3. 对任何一颗二叉树T，如果其终端节点数为n<sub>0</sub>，度为2的节点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1
4. 具有n个节点完全二叉树的深度为[log<sub>2</sub>n]+1
5. 如果对一颗有n个节点的完全二叉树（其深度为[log<sub>2</sub>n]+1）的节点按层序编号（从第1层到第[log<sub>2</sub>n]
   +1层，每层从左到右），则对任一节点i（1<=i<=n），有一下结论：
    1. 如果i=1，则节点i是二叉树的根，无双亲；如果i>1，则其双亲是节点i/2
    2. 如果2i>n，则节点i无左孩子（节点i为叶子节点）；否则其左孩子是节点2i
    3. 如果2i+1>n，则节点i无右孩子（节点i为叶子节点）；否则其右孩子是节点2i+1

## 二、二叉树的存储结构

二叉树可以采用顺序存储，也可以采用链式存储。

### （一）、顺序存储

```cpp
#define MAXSIZE 100     // 二叉树最大节点数
typedef ElemType SqBiTree[MAXSIZE];     // 0号单元存储根节点
SqBiTree T;
```

顺序存储结构采用一组连续存储单元存储数据元素。其更为适合完全二叉树，若用于存储一般二叉树则空间浪费较大。

### （二）、链式存储

链式存储相较于顺序存储更复合树的概念，相印的对比顺序存储在存储一般二叉树上非常有用。

一般情况下使用链式存储有两种节点结构：含有两个指针域的节点结构和含有三个指针域的节点结构。

| lchild | data | rchild |
|:------:|:----:|:------:|

| lchild | data | parent | rchild |
|:------:|:----:|:------:|:------:|

```cpp
struct BiTNode{
    ElemType data;
    struct BiTNode *lchild, *rchild;
};
```

## 三、遍历二叉树和线索二叉树

### （一）、遍历二叉树

**遍历二叉树**是指按某条搜索路径巡访树中每个节点，使得每个节点均被访问一次，而且仅被访问一次。

遍历二叉树是二叉树最常见的最基本的操作，其实质是对二叉树进行线性化。

遍历的三种方式：

1. 先序遍历 根、左、右
2. 中序遍历 左、根、右
3. 后序遍历 左、右、根


> e.g.
> 
> 使用二叉树表示该表达式`a+b*(c-d)-e/f`
> 
> 先序遍历：`-+a*b-cd/ef`
> 
> 中序遍历：`a+b*c-d-e/f`
> 
> 后序遍历：`abcd-*+ef/-`

可以使用递归的方式进行遍历，当然也可以使用栈将算法改为非递归方式。

```cpp
/* 递归方式 */
/* 中序遍历，其他两种遍历方式更改语句顺序即可 */
void InOrderTraverse(BiTree T){
    if(T){
        InOrderTraverse(T->lchild);
        cout<<T -> data;
        InOrderTraverse(T->rchild);
    }
}
```

```cpp
/* 非递归方式 */
/* 中序遍历 */
void InOrderTraverse(BiTree T){
    InitStack(S);
    p=T;
    q=new BiTNode;
    while(p||!StackEmpty(S)){
        if(p){
            Push(S,p);
            p=p->lchild;
        }else{
            Pop(S,q);
            cout<<q->data;
            p=q->rchild;
        }
    }
}
```

无论是递归还是非递归遍历二叉树，由于每个节点都必须访问一次，所以其时间复杂度均为O(n)。
